#!/usr/bin/env bash

#==============================================================================
# Server Management & Optimization Tool
# Version: 2.0.0
# Focus: Network Optimization, Performance, and Server Management
#==============================================================================

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
BOLD='\033[1m'
NC='\033[0m'

# Configuration
SCRIPT_VERSION="2.0.0"
SYSCTL_CONF="/etc/sysctl.conf"
BACKUP_DIR="/root/server-tool-backups"

# Create backup directory
mkdir -p "$BACKUP_DIR"

#==============================================================================
# Utility Functions
#==============================================================================

print_banner() {
    clear
    echo -e "${CYAN}${BOLD}"
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                               â•‘
â•‘         SERVER MANAGEMENT & OPTIMIZATION TOOL                 â•‘
â•‘                     Version 2.0.0                             â•‘
â•‘                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    echo -e "${NC}"
}

print_header() {
    echo -e "\n${BLUE}${BOLD}â•”$(printf 'â•%.0s' {1..63})â•—${NC}"
    printf "${BLUE}${BOLD}â•‘${NC} %-61s ${BLUE}${BOLD}â•‘${NC}\n" "$1"
    echo -e "${BLUE}${BOLD}â•š$(printf 'â•%.0s' {1..63})â•${NC}\n"
}

print_status() {
    local status="$1"
    local message="$2"
    case $status in
        "OK") echo -e "${GREEN}âœ“${NC} $message" ;;
        "WARN") echo -e "${YELLOW}âš ${NC} $message" ;;
        "FAIL") echo -e "${RED}âœ—${NC} $message" ;;
        "INFO") echo -e "${CYAN}â„¹${NC} $message" ;;
    esac
}

check_root() {
    if [ "$(id -u)" != "0" ]; then
        echo -e "${RED}This script must be run as root or with sudo${NC}"
        exit 1
    fi
}

detect_os() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS=$ID
        OS_VERSION=$VERSION_ID
    else
        OS=$(uname -s)
        OS_VERSION=$(uname -r)
    fi
}

backup_file() {
    local file="$1"
    if [ -f "$file" ]; then
        cp "$file" "$BACKUP_DIR/$(basename $file).backup.$(date +%Y%m%d-%H%M%S)"
        print_status "INFO" "Backup created: $file"
    fi
}

press_enter() {
    echo ""
    read -p "$(echo -e ${CYAN}Press Enter to continue...${NC})"
}

#==============================================================================
# System Information
#==============================================================================

show_system_info() {
    print_header "SYSTEM INFORMATION"
    
    # Get info
    HOSTNAME=$(hostname)
    KERNEL=$(uname -r)
    CPU_MODEL=$(lscpu | grep "Model name" | cut -d':' -f2 | xargs)
    CPU_CORES=$(nproc)
    TOTAL_MEM=$(free -h | awk '/^Mem:/ {print $2}')
    USED_MEM=$(free -h | awk '/^Mem:/ {print $3}')
    TOTAL_DISK=$(df -h / | awk 'NR==2 {print $2}')
    USED_DISK=$(df -h / | awk 'NR==2 {print $3}')
    UPTIME=$(uptime -p 2>/dev/null || uptime)
    PUBLIC_IP=$(curl -s --max-time 3 https://api.ipify.org 2>/dev/null || echo "N/A")
    
    # Display
    echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Hostname" "$HOSTNAME"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Kernel" "$KERNEL"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "CPU" "${CPU_MODEL:0:34}"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "CPU Cores" "$CPU_CORES"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Memory" "$USED_MEM / $TOTAL_MEM"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Disk" "$USED_DISK / $TOTAL_DISK"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Uptime" "${UPTIME:0:34}"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: ${YELLOW}%-34s${NC} ${CYAN}â•‘${NC}\n" "Public IP" "$PUBLIC_IP"
    echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
}

#==============================================================================
# TCP Congestion Control - BBR
#==============================================================================

install_bbr() {
    print_header "INSTALL BBR (TCP Congestion Control)"
    
    echo -e "${YELLOW}BBR improves network throughput and reduces latency${NC}\n"
    
    # Check current
    current_cc=$(sysctl net.ipv4.tcp_congestion_control 2>/dev/null | awk '{print $3}')
    echo -e "Current congestion control: ${CYAN}$current_cc${NC}\n"
    
    if [ "$current_cc" = "bbr" ]; then
        print_status "OK" "BBR is already installed and active"
        press_enter
        return
    fi
    
    # Check kernel version
    kernel_version=$(uname -r | cut -d. -f1-2)
    major=$(echo $kernel_version | cut -d. -f1)
    minor=$(echo $kernel_version | cut -d. -f2)
    
    if [ "$major" -lt 4 ] || ([ "$major" -eq 4 ] && [ "$minor" -lt 9 ]); then
        print_status "FAIL" "BBR requires kernel 4.9+. Current: $(uname -r)"
        echo -e "${YELLOW}Please upgrade your kernel first${NC}"
        press_enter
        return
    fi
    
    print_status "OK" "Kernel version compatible: $(uname -r)"
    
    # Backup sysctl.conf
    backup_file "$SYSCTL_CONF"
    
    # Remove old BBR settings
    sed -i '/net.core.default_qdisc/d' "$SYSCTL_CONF"
    sed -i '/net.ipv4.tcp_congestion_control/d' "$SYSCTL_CONF"
    
    # Add BBR settings
    echo "" >> "$SYSCTL_CONF"
    echo "# BBR Congestion Control" >> "$SYSCTL_CONF"
    echo "net.core.default_qdisc=fq" >> "$SYSCTL_CONF"
    echo "net.ipv4.tcp_congestion_control=bbr" >> "$SYSCTL_CONF"
    
    # Apply settings
    sysctl -p > /dev/null 2>&1
    
    # Verify
    if sysctl net.ipv4.tcp_congestion_control | grep -q "bbr"; then
        print_status "OK" "BBR installed and activated successfully!"
        echo ""
        print_status "INFO" "BBR will persist after reboot"
    else
        print_status "FAIL" "Failed to activate BBR"
    fi
    
    press_enter
}

#==============================================================================
# TCP Congestion Control - Hybla
#==============================================================================

install_hybla() {
    print_header "INSTALL HYBLA (TCP Congestion Control)"
    
    echo -e "${YELLOW}Hybla is optimized for high-latency networks (satellite, long-distance)${NC}\n"
    
    # Check current
    current_cc=$(sysctl net.ipv4.tcp_congestion_control 2>/dev/null | awk '{print $3}')
    echo -e "Current congestion control: ${CYAN}$current_cc${NC}\n"
    
    if [ "$current_cc" = "hybla" ]; then
        print_status "OK" "Hybla is already installed and active"
        press_enter
        return
    fi
    
    # Load hybla module
    modprobe tcp_hybla 2>/dev/null
    
    if ! lsmod | grep -q tcp_hybla; then
        print_status "FAIL" "Cannot load tcp_hybla module"
        echo -e "${YELLOW}Your kernel may not support Hybla${NC}"
        press_enter
        return
    fi
    
    print_status "OK" "Hybla module loaded"
    
    # Make module load on boot
    if ! grep -q "tcp_hybla" /etc/modules 2>/dev/null; then
        echo "tcp_hybla" >> /etc/modules
    fi
    
    # Backup sysctl.conf
    backup_file "$SYSCTL_CONF"
    
    # Remove old settings
    sed -i '/net.core.default_qdisc/d' "$SYSCTL_CONF"
    sed -i '/net.ipv4.tcp_congestion_control/d' "$SYSCTL_CONF"
    
    # Add Hybla settings
    echo "" >> "$SYSCTL_CONF"
    echo "# Hybla Congestion Control" >> "$SYSCTL_CONF"
    echo "net.core.default_qdisc=fq" >> "$SYSCTL_CONF"
    echo "net.ipv4.tcp_congestion_control=hybla" >> "$SYSCTL_CONF"
    
    # Apply settings
    sysctl -p > /dev/null 2>&1
    
    # Verify
    if sysctl net.ipv4.tcp_congestion_control | grep -q "hybla"; then
        print_status "OK" "Hybla installed and activated successfully!"
        echo ""
        print_status "INFO" "Hybla will persist after reboot"
    else
        print_status "FAIL" "Failed to activate Hybla"
    fi
    
    press_enter
}

#==============================================================================
# Remove TCP Optimization
#==============================================================================

remove_tcp_optimization() {
    print_header "REMOVE TCP OPTIMIZATION"
    
    echo -e "${YELLOW}This will remove BBR/Hybla and restore default settings${NC}\n"
    
    read -p "$(echo -e ${RED}Are you sure? [y/N]:${NC} )" confirm
    if [[ ! $confirm =~ ^[Yy]$ ]]; then
        return
    fi
    
    # Backup sysctl.conf
    backup_file "$SYSCTL_CONF"
    
    # Remove settings
    sed -i '/# BBR Congestion Control/d' "$SYSCTL_CONF"
    sed -i '/# Hybla Congestion Control/d' "$SYSCTL_CONF"
    sed -i '/net.core.default_qdisc/d' "$SYSCTL_CONF"
    sed -i '/net.ipv4.tcp_congestion_control/d' "$SYSCTL_CONF"
    
    # Set to default (cubic)
    sysctl -w net.ipv4.tcp_congestion_control=cubic > /dev/null 2>&1
    
    # Remove hybla from modules
    sed -i '/tcp_hybla/d' /etc/modules 2>/dev/null
    
    print_status "OK" "TCP optimization removed"
    print_status "INFO" "Default congestion control (cubic) restored"
    
    press_enter
}

#==============================================================================
# MTU Finder & Optimizer
#==============================================================================

mtu_finder() {
    print_header "MTU FINDER & OPTIMIZER"
    
    # Get primary interface
    PRIMARY_IFACE=$(ip route | grep default | awk '{print $5}' | head -1)
    
    if [ -z "$PRIMARY_IFACE" ]; then
        print_status "FAIL" "Cannot detect primary network interface"
        press_enter
        return
    fi
    
    current_mtu=$(ip link show "$PRIMARY_IFACE" 2>/dev/null | grep -oP 'mtu \K\d+' || echo "1500")
    echo -e "Interface: ${CYAN}$PRIMARY_IFACE${NC}"
    echo -e "Current MTU: ${CYAN}$current_mtu${NC}\n"
    
    echo -e "${CYAN}Select test destination:${NC}"
    echo "  1) Google DNS (8.8.8.8)"
    echo "  2) Cloudflare DNS (1.1.1.1)"
    echo "  3) Custom IP"
    echo "  0) Back"
    echo ""
    read -p "Choice: " dest_choice
    
    case $dest_choice in
        1) test_ip="8.8.8.8" ;;
        2) test_ip="1.1.1.1" ;;
        3) read -p "Enter IP address: " test_ip ;;
        0) return ;;
        *) print_status "FAIL" "Invalid choice"; press_enter; return ;;
    esac
    
    # Test connectivity
    if ! ping -c 1 -W 2 "$test_ip" &>/dev/null; then
        print_status "FAIL" "Cannot reach $test_ip"
        press_enter
        return
    fi
    
    print_status "OK" "Testing connectivity to $test_ip"
    
    echo ""
    echo -e "${CYAN}Finding optimal MTU...${NC}\n"
    
    # Binary search for optimal MTU
    local min_mtu=1000
    local max_mtu=1500
    local optimal_mtu=$min_mtu
    local step=10
    
    for ((mtu=$min_mtu; mtu<=$max_mtu; mtu+=$step)); do
        local payload=$((mtu - 28))
        echo -ne "${GRAY}Testing MTU $mtu...${NC}\r"
        
        if ping -M do -c 1 -s $payload -W 1 "$test_ip" &>/dev/null; then
            optimal_mtu=$mtu
            echo -e "${GREEN}âœ“${NC} MTU $mtu: ${GREEN}OK${NC}     "
        else
            echo -e "${RED}âœ—${NC} MTU $mtu: ${RED}Failed${NC}"
            break
        fi
    done
    
    # Recommend MTU
    local recommended_mtu=$((optimal_mtu - 2))
    
    echo ""
    print_status "OK" "Optimal MTU found: $optimal_mtu"
    print_status "INFO" "Recommended MTU: $recommended_mtu"
    
    echo ""
    read -p "$(echo -e ${YELLOW}Apply MTU $recommended_mtu? [y/N]:${NC} )" apply_mtu
    
    if [[ $apply_mtu =~ ^[Yy]$ ]]; then
        # Set MTU temporarily
        ip link set dev "$PRIMARY_IFACE" mtu "$recommended_mtu" 2>/dev/null
        print_status "OK" "MTU temporarily set to $recommended_mtu"
        
        # Make permanent
        if [ -f "/etc/network/interfaces" ]; then
            backup_file "/etc/network/interfaces"
            if ! grep -q "mtu $recommended_mtu" /etc/network/interfaces; then
                sed -i "/iface $PRIMARY_IFACE/a \    mtu $recommended_mtu" /etc/network/interfaces 2>/dev/null
                print_status "OK" "MTU saved to /etc/network/interfaces"
            fi
        elif [ -f "/etc/sysconfig/network-scripts/ifcfg-$PRIMARY_IFACE" ]; then
            local ifcfg="/etc/sysconfig/network-scripts/ifcfg-$PRIMARY_IFACE"
            backup_file "$ifcfg"
            if grep -q "MTU=" "$ifcfg"; then
                sed -i "s/MTU=.*/MTU=$recommended_mtu/" "$ifcfg"
            else
                echo "MTU=$recommended_mtu" >> "$ifcfg"
            fi
            print_status "OK" "MTU saved to $ifcfg"
        else
            print_status "WARN" "Manual configuration may be needed for persistence"
        fi
        
        print_status "INFO" "MTU will persist after reboot"
    fi
    
    press_enter
}

#==============================================================================
# DNS Optimizer
#==============================================================================

optimize_dns() {
    print_header "DNS OPTIMIZER"
    
    echo -e "${YELLOW}Testing multiple DNS servers to find the fastest...${NC}\n"
    
    # DNS servers to test
    declare -A dns_servers=(
        ["Google"]="8.8.8.8"
        ["Cloudflare"]="1.1.1.1"
        ["Quad9"]="9.9.9.9"
        ["OpenDNS"]="208.67.222.222"
        ["Shecan"]="178.22.122.100"
        ["403"]="10.202.10.202"
    )
    
    declare -A dns_times
    
    # Test each DNS
    for name in "${!dns_servers[@]}"; do
        ip="${dns_servers[$name]}"
        echo -ne "${GRAY}Testing $name ($ip)...${NC}\r"
        
        # Test with dig
        if command -v dig &>/dev/null; then
            response_time=$(dig @$ip google.com +stats 2>/dev/null | grep "Query time:" | awk '{print $4}')
            if [ -n "$response_time" ]; then
                dns_times["$name"]="$response_time"
                echo -e "${GREEN}âœ“${NC} $name ($ip): ${CYAN}${response_time}ms${NC}          "
            else
                echo -e "${RED}âœ—${NC} $name ($ip): ${RED}Failed${NC}          "
            fi
        else
            # Fallback to ping
            ping_time=$(ping -c 3 -W 2 $ip 2>/dev/null | tail -1 | awk -F'/' '{print $5}' | cut -d'.' -f1)
            if [ -n "$ping_time" ]; then
                dns_times["$name"]="$ping_time"
                echo -e "${GREEN}âœ“${NC} $name ($ip): ${CYAN}~${ping_time}ms${NC}          "
            else
                echo -e "${RED}âœ—${NC} $name ($ip): ${RED}Failed${NC}          "
            fi
        fi
    done
    
    # Find fastest
    fastest_dns=""
    fastest_time=999999
    
    for name in "${!dns_times[@]}"; do
        time="${dns_times[$name]}"
        if [ "$time" -lt "$fastest_time" ]; then
            fastest_time=$time
            fastest_dns=$name
        fi
    done
    
    if [ -z "$fastest_dns" ]; then
        print_status "FAIL" "No DNS servers responded"
        press_enter
        return
    fi
    
    fastest_ip="${dns_servers[$fastest_dns]}"
    
    echo ""
    print_status "OK" "Fastest DNS: $fastest_dns ($fastest_ip) - ${fastest_time}ms"
    
    echo ""
    read -p "$(echo -e ${YELLOW}Apply this DNS? [y/N]:${NC} )" apply_dns
    
    if [[ $apply_dns =~ ^[Yy]$ ]]; then
        # Backup resolv.conf
        backup_file "/etc/resolv.conf"
        
        # Set DNS
        cat > /etc/resolv.conf << EOF
nameserver $fastest_ip
nameserver 8.8.8.8
EOF
        
        # Make immutable (prevent changes)
        chattr +i /etc/resolv.conf 2>/dev/null || true
        
        print_status "OK" "DNS set to $fastest_dns ($fastest_ip)"
        print_status "INFO" "DNS will persist after reboot"
    fi
    
    press_enter
}

#==============================================================================
# Block/Unblock ICMP (Ping)
#==============================================================================

manage_ping() {
    print_header "BLOCK/UNBLOCK SERVER PING"
    
    # Check current status
    current_setting=$(sysctl net.ipv4.icmp_echo_ignore_all 2>/dev/null | awk '{print $3}')
    
    if [ "$current_setting" = "1" ]; then
        echo -e "Current status: ${RED}Ping is BLOCKED${NC}\n"
    else
        echo -e "Current status: ${GREEN}Ping is ALLOWED${NC}\n"
    fi
    
    echo "  1) Block Ping"
    echo "  2) Unblock Ping"
    echo "  0) Back"
    echo ""
    read -p "Choice: " ping_choice
    
    case $ping_choice in
        1)
            # Block ping
            backup_file "$SYSCTL_CONF"
            sed -i '/net.ipv4.icmp_echo_ignore_all/d' "$SYSCTL_CONF"
            echo "net.ipv4.icmp_echo_ignore_all=1" >> "$SYSCTL_CONF"
            sysctl -w net.ipv4.icmp_echo_ignore_all=1 > /dev/null 2>&1
            print_status "OK" "Ping blocked successfully"
            print_status "INFO" "Setting will persist after reboot"
            ;;
        2)
            # Unblock ping
            backup_file "$SYSCTL_CONF"
            sed -i '/net.ipv4.icmp_echo_ignore_all/d' "$SYSCTL_CONF"
            echo "net.ipv4.icmp_echo_ignore_all=0" >> "$SYSCTL_CONF"
            sysctl -w net.ipv4.icmp_echo_ignore_all=0 > /dev/null 2>&1
            print_status "OK" "Ping unblocked successfully"
            print_status "INFO" "Setting will persist after reboot"
            ;;
        0)
            return
            ;;
        *)
            print_status "FAIL" "Invalid choice"
            ;;
    esac
    
    press_enter
}

#==============================================================================
# Network & Server Optimization Menu
#==============================================================================

network_optimization_menu() {
    while true; do
        print_banner
        show_system_info
        
        print_header "NETWORK & SERVER OPTIMIZATION"
        
        echo -e "${WHITE}  1)${NC} Install BBR (TCP Congestion Control)"
        echo -e "${WHITE}  2)${NC} Install Hybla (TCP for High Latency)"
        echo -e "${WHITE}  3)${NC} Remove TCP Optimization (BBR/Hybla)"
        echo -e "${WHITE}  4)${NC} MTU Finder + Auto Set"
        echo -e "${WHITE}  5)${NC} DNS Optimizer (Find & Set Fastest)"
        echo -e "${WHITE}  6)${NC} Block/Unblock Server Ping"
        echo -e "${WHITE}  0)${NC} â† Back to Main Menu"
        
        echo ""
        read -p "$(echo -e ${YELLOW}Select option:${NC} )" choice
        
        case $choice in
            1) install_bbr ;;
            2) install_hybla ;;
            3) remove_tcp_optimization ;;
            4) mtu_finder ;;
            5) optimize_dns ;;
            6) manage_ping ;;
            0) break ;;
            *) print_status "FAIL" "Invalid option"; sleep 1 ;;
        esac
    done
}

#==============================================================================
# Repository Mirror Optimizer
#==============================================================================

optimize_mirrors() {
    print_header "OPTIMIZE APT MIRRORS"
    
    if [ "$OS" != "ubuntu" ] && [ "$OS" != "debian" ]; then
        print_status "FAIL" "This feature only works on Ubuntu/Debian"
        press_enter
        return
    fi
    
    echo -e "${YELLOW}Finding fastest mirrors for your location...${NC}\n"
    
    # Backup sources.list
    backup_file "/etc/apt/sources.list"
    
    # Install netselect-apt if needed
    if ! command -v netselect-apt &>/dev/null; then
        echo -e "${CYAN}Installing netselect-apt...${NC}"
        apt-get update -qq > /dev/null 2>&1
        apt-get install -y netselect-apt > /dev/null 2>&1
    fi
    
    if command -v netselect-apt &>/dev/null; then
        print_status "OK" "Testing mirrors..."
        
        # Generate new sources.list
        cd /tmp
        netselect-apt -n -o sources.list.new 2>/dev/null
        
        if [ -f "sources.list.new" ]; then
            # Show fastest mirror
            fastest=$(grep "^deb http" sources.list.new | head -1 | awk '{print $2}')
            print_status "OK" "Fastest mirror found: $fastest"
            
            echo ""
            read -p "$(echo -e ${YELLOW}Apply this mirror? [y/N]:${NC} )" apply_mirror
            
            if [[ $apply_mirror =~ ^[Yy]$ ]]; then
                cp sources.list.new /etc/apt/sources.list
                apt-get update -qq > /dev/null 2>&1
                print_status "OK" "Mirror updated successfully"
                rm -f sources.list.new
            fi
        else
            print_status "FAIL" "Could not find optimal mirror"
        fi
    else
        print_status "WARN" "netselect-apt not available"
    fi
    
    press_enter
}

#==============================================================================
# System Benchmark
#==============================================================================

run_benchmark() {
    print_header "SYSTEM BENCHMARK"
    
    echo -e "${YELLOW}Running comprehensive benchmark...${NC}\n"
    echo -e "${CYAN}This may take a few minutes${NC}\n"
    
    # Run bench.sh
    curl -Lso- bench.sh 2>/dev/null | bash
    
    press_enter
}

#==============================================================================
# Main Menu
#==============================================================================

main_menu() {
    while true; do
        print_banner
        show_system_info
        
        echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
        echo -e "${CYAN}${BOLD}                      MAIN MENU                            ${NC}"
        echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
        
        echo -e "${WHITE}  1)${NC} ğŸŒ Network & Server Optimization"
        echo -e "${WHITE}  2)${NC} ğŸ” Check IP Reputation & Security"
        echo -e "${WHITE}  3)${NC} ğŸ“Š System Benchmark"
        echo -e "${WHITE}  4)${NC} ğŸ”„ Optimize Repository Mirrors"
        echo -e "${WHITE}  5)${NC} ğŸ“‹ View System Logs"
        echo -e "${WHITE}  0)${NC} âŒ Exit"
        
        echo -e "\n${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
        
        read -p "$(echo -e ${YELLOW}Select option:${NC} )" choice
        
        case $choice in
            1) network_optimization_menu ;;
            2) echo "Coming soon..."; press_enter ;;
            3) run_benchmark ;;
            4) optimize_mirrors ;;
            5) echo "Coming soon..."; press_enter ;;
            0) 
                echo -e "\n${GREEN}Thank you for using Server Management Tool!${NC}\n"
                exit 0
                ;;
            *)
                print_status "FAIL" "Invalid option"
                sleep 1
                ;;
        esac
    done
}

#==============================================================================
# Main Execution
#==============================================================================

# Check root
check_root

# Detect OS
detect_os

# Start
main_menu
