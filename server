#!/usr/bin/env bash
#==============================================================================
# Server Management & Optimization Tool
# Version: 2.1.0
# Focus: Network Optimization, Performance, Server Management & Logs
#==============================================================================

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
BOLD='\033[1m'
NC='\033[0m'

# Configuration
SCRIPT_VERSION="2.1.0"
SYSCTL_CONF="/etc/sysctl.conf"
BACKUP_DIR="/root/server-tool-backups"

# Create backup directory
mkdir -p "$BACKUP_DIR"

#==============================================================================
# Utility Functions
#==============================================================================

print_banner() {
    clear
    echo -e "${CYAN}${BOLD}"
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                               â•‘
â•‘         SERVER MANAGEMENT & OPTIMIZATION TOOL                 â•‘
â•‘                      Version 2.1.0                            â•‘
â•‘                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    echo -e "${NC}"
}

print_header() {
    echo -e "\n${BLUE}${BOLD}â•”$(printf 'â•%.0s' {1..63})â•—${NC}"
    printf "${BLUE}${BOLD}â•‘${NC} %-61s ${BLUE}${BOLD}â•‘${NC}\n" "$1"
    echo -e "${BLUE}${BOLD}â•š$(printf 'â•%.0s' {1..63})â•${NC}\n"
}

print_status() {
    local status="$1"
    local message="$2"
    
    case $status in
        "OK")
            echo -e "${GREEN}âœ“${NC} $message"
            ;;
        "WARN")
            echo -e "${YELLOW}âš ${NC} $message"
            ;;
        "FAIL")
            echo -e "${RED}âœ—${NC} $message"
            ;;
        "INFO")
            echo -e "${CYAN}â„¹${NC} $message"
            ;;
    esac
}

# Progress bar function
show_progress() {
    local current=$1
    local total=$2
    local width=50
    local percentage=$((current * 100 / total))
    local filled=$((width * current / total))
    local empty=$((width - filled))
    
    printf "\r${CYAN}["
    printf "${GREEN}%${filled}s" | tr ' ' 'â–ˆ'
    printf "${GRAY}%${empty}s" | tr ' ' 'â–‘'
    printf "${CYAN}] ${BOLD}${percentage}%%${NC}"
}

check_root() {
    if [ "$(id -u)" != "0" ]; then
        echo -e "${RED}This script must be run as root or with sudo${NC}"
        exit 1
    fi
}

detect_os() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS=$ID
        OS_VERSION=$VERSION_ID
    else
        OS=$(uname -s)
        OS_VERSION=$(uname -r)
    fi
}

backup_file() {
    local file="$1"
    if [ -f "$file" ]; then
        cp "$file" "$BACKUP_DIR/$(basename $file).backup.$(date +%Y%m%d-%H%M%S)"
        print_status "INFO" "Backup created: $file"
    fi
}

press_enter() {
    echo ""
    echo -ne "${CYAN}Press Enter to continue...${NC}"
    read
}

#==============================================================================
# System Information
#==============================================================================

show_system_info() {
    print_header "SYSTEM INFORMATION"
    
    # Get info
    HOSTNAME=$(hostname)
    KERNEL=$(uname -r)
    CPU_MODEL=$(lscpu | grep "Model name" | cut -d':' -f2 | xargs)
    CPU_CORES=$(nproc)
    TOTAL_MEM=$(free -h | awk '/^Mem:/ {print $2}')
    USED_MEM=$(free -h | awk '/^Mem:/ {print $3}')
    TOTAL_DISK=$(df -h / | awk 'NR==2 {print $2}')
    USED_DISK=$(df -h / | awk 'NR==2 {print $3}')
    UPTIME=$(uptime -p 2>/dev/null || uptime)
    PUBLIC_IP=$(curl -s --max-time 3 https://api.ipify.org 2>/dev/null || echo "N/A")
    
    # Display
    echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Hostname" "$HOSTNAME"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Kernel" "$KERNEL"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "CPU" "${CPU_MODEL:0:34}"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "CPU Cores" "$CPU_CORES"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Memory" "$USED_MEM / $TOTAL_MEM"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Disk" "$USED_DISK / $TOTAL_DISK"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Uptime" "${UPTIME:0:34}"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: ${YELLOW}%-34s${NC} ${CYAN}â•‘${NC}\n" "Public IP" "$PUBLIC_IP"
    echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
}

#==============================================================================
# TCP Congestion Control - BBR
#==============================================================================

install_bbr() {
    print_header "INSTALL BBR (TCP Congestion Control)"
    
    echo -e "${YELLOW}BBR improves network throughput and reduces latency${NC}\n"
    
    # Check current
    current_cc=$(sysctl net.ipv4.tcp_congestion_control 2>/dev/null | awk '{print $3}')
    echo -e "Current congestion control: ${CYAN}$current_cc${NC}\n"
    
    if [ "$current_cc" = "bbr" ]; then
        print_status "OK" "BBR is already installed and active"
        press_enter
        return
    fi
    
    # Check kernel version
    kernel_version=$(uname -r | cut -d. -f1-2)
    major=$(echo $kernel_version | cut -d. -f1)
    minor=$(echo $kernel_version | cut -d. -f2)
    
    if [ "$major" -lt 4 ] || ([ "$major" -eq 4 ] && [ "$minor" -lt 9 ]); then
        print_status "FAIL" "BBR requires kernel 4.9+. Current: $(uname -r)"
        echo -e "${YELLOW}Please upgrade your kernel first${NC}"
        press_enter
        return
    fi
    
    print_status "OK" "Kernel version compatible: $(uname -r)"
    
    # Backup sysctl.conf
    backup_file "$SYSCTL_CONF"
    
    # Remove old BBR settings
    sed -i '/net.core.default_qdisc/d' "$SYSCTL_CONF"
    sed -i '/net.ipv4.tcp_congestion_control/d' "$SYSCTL_CONF"
    
    # Add BBR settings
    echo "" >> "$SYSCTL_CONF"
    echo "# BBR Congestion Control" >> "$SYSCTL_CONF"
    echo "net.core.default_qdisc=fq" >> "$SYSCTL_CONF"
    echo "net.ipv4.tcp_congestion_control=bbr" >> "$SYSCTL_CONF"
    
    # Apply settings
    sysctl -p > /dev/null 2>&1
    
    # Verify
    if sysctl net.ipv4.tcp_congestion_control | grep -q "bbr"; then
        print_status "OK" "BBR installed and activated successfully!"
        echo ""
        print_status "INFO" "BBR will persist after reboot"
    else
        print_status "FAIL" "Failed to activate BBR"
    fi
    
    press_enter
}

#==============================================================================
# TCP Congestion Control - Hybla
#==============================================================================

install_hybla() {
    print_header "INSTALL HYBLA (TCP Congestion Control)"
    
    echo -e "${YELLOW}Hybla is optimized for high-latency networks (satellite, long-distance)${NC}\n"
    
    # Check current
    current_cc=$(sysctl net.ipv4.tcp_congestion_control 2>/dev/null | awk '{print $3}')
    echo -e "Current congestion control: ${CYAN}$current_cc${NC}\n"
    
    if [ "$current_cc" = "hybla" ]; then
        print_status "OK" "Hybla is already installed and active"
        press_enter
        return
    fi
    
    # Load hybla module
    modprobe tcp_hybla 2>/dev/null
    
    if ! lsmod | grep -q tcp_hybla; then
        print_status "FAIL" "Cannot load tcp_hybla module"
        echo -e "${YELLOW}Your kernel may not support Hybla${NC}"
        press_enter
        return
    fi
    
    print_status "OK" "Hybla module loaded"
    
    # Make module load on boot
    if ! grep -q "tcp_hybla" /etc/modules 2>/dev/null; then
        echo "tcp_hybla" >> /etc/modules
    fi
    
    # Backup sysctl.conf
    backup_file "$SYSCTL_CONF"
    
    # Remove old settings
    sed -i '/net.core.default_qdisc/d' "$SYSCTL_CONF"
    sed -i '/net.ipv4.tcp_congestion_control/d' "$SYSCTL_CONF"
    
    # Add Hybla settings
    echo "" >> "$SYSCTL_CONF"
    echo "# Hybla Congestion Control" >> "$SYSCTL_CONF"
    echo "net.core.default_qdisc=fq" >> "$SYSCTL_CONF"
    echo "net.ipv4.tcp_congestion_control=hybla" >> "$SYSCTL_CONF"
    
    # Apply settings
    sysctl -p > /dev/null 2>&1
    
    # Verify
    if sysctl net.ipv4.tcp_congestion_control | grep -q "hybla"; then
        print_status "OK" "Hybla installed and activated successfully!"
        echo ""
        print_status "INFO" "Hybla will persist after reboot"
    else
        print_status "FAIL" "Failed to activate Hybla"
    fi
    
    press_enter
}

#==============================================================================
# Remove TCP Optimization
#==============================================================================

remove_tcp_optimization() {
    print_header "REMOVE TCP OPTIMIZATION"
    
    echo -e "${YELLOW}This will remove BBR/Hybla and restore default settings${NC}\n"
    
    echo -ne "${RED}Are you sure? [y/N]: ${NC}"
    read confirm
    if [[ ! $confirm =~ ^[Yy]$ ]]; then
        return
    fi
    
    # Backup sysctl.conf
    backup_file "$SYSCTL_CONF"
    
    # Remove settings
    sed -i '/# BBR Congestion Control/d' "$SYSCTL_CONF"
    sed -i '/# Hybla Congestion Control/d' "$SYSCTL_CONF"
    sed -i '/net.core.default_qdisc/d' "$SYSCTL_CONF"
    sed -i '/net.ipv4.tcp_congestion_control/d' "$SYSCTL_CONF"
    
    # Set to default (cubic)
    sysctl -w net.ipv4.tcp_congestion_control=cubic > /dev/null 2>&1
    
    # Remove hybla from modules
    sed -i '/tcp_hybla/d' /etc/modules 2>/dev/null
    
    print_status "OK" "TCP optimization removed"
    print_status "INFO" "Default congestion control (cubic) restored"
    
    press_enter
}

#==============================================================================
# MTU Finder & Optimizer
#==============================================================================

mtu_finder() {
    print_header "MTU FINDER & OPTIMIZER"
    
    # Get primary interface
    PRIMARY_IFACE=$(ip route | grep default | awk '{print $5}' | head -1)
    
    if [ -z "$PRIMARY_IFACE" ]; then
        print_status "FAIL" "Cannot detect primary network interface"
        press_enter
        return
    fi
    
    current_mtu=$(ip link show "$PRIMARY_IFACE" 2>/dev/null | grep -oP 'mtu \K\d+' || echo "1500")
    
    echo -e "Interface: ${CYAN}$PRIMARY_IFACE${NC}"
    echo -e "Current MTU: ${CYAN}$current_mtu${NC}\n"
    
    echo -e "${CYAN}Select test destination:${NC}"
    echo "  1) Google DNS (8.8.8.8)"
    echo "  2) Cloudflare DNS (1.1.1.1)"
    echo "  3) Custom IP"
    echo "  0) Back"
    echo ""
    read -p "Choice: " dest_choice
    
    case $dest_choice in
        1) test_ip="8.8.8.8" ;;
        2) test_ip="1.1.1.1" ;;
        3) read -p "Enter IP address: " test_ip ;;
        0) return ;;
        *) print_status "FAIL" "Invalid choice"; press_enter; return ;;
    esac
    
    # Test connectivity
    if ! ping -c 1 -W 2 "$test_ip" &>/dev/null; then
        print_status "FAIL" "Cannot reach $test_ip"
        press_enter
        return
    fi
    
    print_status "OK" "Testing connectivity to $test_ip"
    echo ""
    echo -e "${CYAN}Finding optimal MTU...${NC}\n"
    
    # Binary search for optimal MTU
    local min_mtu=1000
    local max_mtu=1500
    local optimal_mtu=$min_mtu
    local step=10
    
    for ((mtu=$min_mtu; mtu<=$max_mtu; mtu+=$step)); do
        local payload=$((mtu - 28))
        echo -ne "${GRAY}Testing MTU $mtu...${NC}\r"
        
        if ping -M do -c 1 -s $payload -W 1 "$test_ip" &>/dev/null; then
            optimal_mtu=$mtu
            echo -e "${GREEN}âœ“${NC} MTU $mtu: ${GREEN}OK${NC}       "
        else
            echo -e "${RED}âœ—${NC} MTU $mtu: ${RED}Failed${NC}"
            break
        fi
    done
    
    # Recommend MTU
    local recommended_mtu=$((optimal_mtu - 2))
    
    echo ""
    print_status "OK" "Optimal MTU found: $optimal_mtu"
    print_status "INFO" "Recommended MTU: $recommended_mtu"
    echo ""
    echo -ne "${YELLOW}Apply MTU ${recommended_mtu}? [y/N]: ${NC}"
    read apply_mtu
    
    if [[ $apply_mtu =~ ^[Yy]$ ]]; then
        # Set MTU temporarily
        ip link set dev "$PRIMARY_IFACE" mtu "$recommended_mtu" 2>/dev/null
        print_status "OK" "MTU temporarily set to $recommended_mtu"
        
        # Make permanent
        if [ -f "/etc/network/interfaces" ]; then
            backup_file "/etc/network/interfaces"
            if ! grep -q "mtu $recommended_mtu" /etc/network/interfaces; then
                sed -i "/iface $PRIMARY_IFACE/a \    mtu $recommended_mtu" /etc/network/interfaces 2>/dev/null
                print_status "OK" "MTU saved to /etc/network/interfaces"
            fi
        elif [ -f "/etc/sysconfig/network-scripts/ifcfg-$PRIMARY_IFACE" ]; then
            local ifcfg="/etc/sysconfig/network-scripts/ifcfg-$PRIMARY_IFACE"
            backup_file "$ifcfg"
            if grep -q "MTU=" "$ifcfg"; then
                sed -i "s/MTU=.*/MTU=$recommended_mtu/" "$ifcfg"
            else
                echo "MTU=$recommended_mtu" >> "$ifcfg"
            fi
            print_status "OK" "MTU saved to $ifcfg"
        else
            print_status "WARN" "Manual configuration may be needed for persistence"
        fi
        
        print_status "INFO" "MTU will persist after reboot"
    fi
    
    press_enter
}

#==============================================================================
# DNS Optimizer with Progress Bar
#==============================================================================

optimize_dns() {
    print_header "DNS OPTIMIZER"
    
    echo -e "${YELLOW}Testing multiple DNS servers to find the fastest...${NC}\n"
    
    # DNS servers to test
    declare -A dns_servers=(
        ["Google"]="8.8.8.8"
        ["Cloudflare"]="1.1.1.1"
        ["Quad9"]="9.9.9.9"
        ["OpenDNS"]="208.67.222.222"
        ["Shecan"]="178.22.122.100"
        ["403"]="10.202.10.202"
    )
    
    declare -A dns_times
    
    local total=${#dns_servers[@]}
    local count=0
    
    echo -e "${CYAN}${BOLD}Testing DNS Servers:${NC}\n"
    
    # Test each DNS
    for name in "${!dns_servers[@]}"; do
        ip="${dns_servers[$name]}"
        count=$((count + 1))
        
        # Show progress bar
        show_progress $count $total
        echo -ne " Testing ${CYAN}$name${NC}..."
        
        # Test with dig if available
        if command -v dig &>/dev/null; then
            response_time=$(dig @$ip google.com +stats 2>/dev/null | grep "Query time:" | awk '{print $4}')
            
            if [ -n "$response_time" ]; then
                dns_times["$name"]="$response_time"
                echo -e "\r$(show_progress $count $total) ${GREEN}âœ“${NC} $name ($ip): ${CYAN}${response_time}ms${NC}                    "
            else
                echo -e "\r$(show_progress $count $total) ${RED}âœ—${NC} $name ($ip): ${RED}Failed${NC}                    "
            fi
        else
            # Fallback to ping
            ping_time=$(ping -c 3 -W 2 $ip 2>/dev/null | tail -1 | awk -F'/' '{print $5}' | cut -d'.' -f1)
            
            if [ -n "$ping_time" ]; then
                dns_times["$name"]="$ping_time"
                echo -e "\r$(show_progress $count $total) ${GREEN}âœ“${NC} $name ($ip): ${CYAN}~${ping_time}ms${NC}                    "
            else
                echo -e "\r$(show_progress $count $total) ${RED}âœ—${NC} $name ($ip): ${RED}Failed${NC}                    "
            fi
        fi
        
        sleep 0.2
    done
    
    echo ""
    
    # Find fastest
    fastest_dns=""
    fastest_time=999999
    
    for name in "${!dns_times[@]}"; do
        time="${dns_times[$name]}"
        if [ "$time" -lt "$fastest_time" ]; then
            fastest_time=$time
            fastest_dns=$name
        fi
    done
    
    if [ -z "$fastest_dns" ]; then
        print_status "FAIL" "No DNS servers responded"
        press_enter
        return
    fi
    
    fastest_ip="${dns_servers[$fastest_dns]}"
    
    echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    print_status "OK" "Fastest DNS: ${BOLD}$fastest_dns${NC} ($fastest_ip) - ${GREEN}${fastest_time}ms${NC}"
    echo ""
    
    # Show ranking
    echo -e "${CYAN}${BOLD}DNS Ranking:${NC}"
    echo ""
    
    # Sort results
    for name in $(for n in "${!dns_times[@]}"; do echo "$n ${dns_times[$n]}"; done | sort -k2 -n | awk '{print $1}'); do
        ip="${dns_servers[$name]}"
        time="${dns_times[$name]}"
        
        if [ "$name" = "$fastest_dns" ]; then
            echo -e "  ${GREEN}ðŸ¥‡ $name${NC} ($ip) - ${GREEN}${time}ms${NC}"
        else
            echo -e "  ${CYAN}  $name${NC} ($ip) - ${CYAN}${time}ms${NC}"
        fi
    done
    
    echo ""
    echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    echo -ne "${YELLOW}Apply fastest DNS (${fastest_dns})? [y/N]: ${NC}"
    read apply_dns
    
    if [[ $apply_dns =~ ^[Yy]$ ]]; then
        # Backup resolv.conf
        backup_file "/etc/resolv.conf"
        
        # Set DNS
        cat > /etc/resolv.conf << EOF
nameserver $fastest_ip
nameserver 8.8.8.8
EOF
        
        # Make immutable (prevent changes)
        chattr +i /etc/resolv.conf 2>/dev/null || true
        
        print_status "OK" "DNS set to $fastest_dns ($fastest_ip)"
        print_status "INFO" "DNS will persist after reboot"
    fi
    
    press_enter
}

#==============================================================================
# Block/Unblock ICMP (Ping)
#==============================================================================

manage_ping() {
    print_header "BLOCK/UNBLOCK SERVER PING"
    
    # Check current status
    current_setting=$(sysctl net.ipv4.icmp_echo_ignore_all 2>/dev/null | awk '{print $3}')
    
    if [ "$current_setting" = "1" ]; then
        echo -e "Current status: ${RED}Ping is BLOCKED${NC}\n"
    else
        echo -e "Current status: ${GREEN}Ping is ALLOWED${NC}\n"
    fi
    
    echo "  1) Block Ping"
    echo "  2) Unblock Ping"
    echo "  0) Back"
    echo ""
    read -p "Choice: " ping_choice
    
    case $ping_choice in
        1)
            # Block ping
            backup_file "$SYSCTL_CONF"
            sed -i '/net.ipv4.icmp_echo_ignore_all/d' "$SYSCTL_CONF"
            echo "net.ipv4.icmp_echo_ignore_all=1" >> "$SYSCTL_CONF"
            sysctl -w net.ipv4.icmp_echo_ignore_all=1 > /dev/null 2>&1
            print_status "OK" "Ping blocked successfully"
            print_status "INFO" "Setting will persist after reboot"
            ;;
        2)
            # Unblock ping
            backup_file "$SYSCTL_CONF"
            sed -i '/net.ipv4.icmp_echo_ignore_all/d' "$SYSCTL_CONF"
            echo "net.ipv4.icmp_echo_ignore_all=0" >> "$SYSCTL_CONF"
            sysctl -w net.ipv4.icmp_echo_ignore_all=0 > /dev/null 2>&1
            print_status "OK" "Ping unblocked successfully"
            print_status "INFO" "Setting will persist after reboot"
            ;;
        0)
            return
            ;;
        *)
            print_status "FAIL" "Invalid choice"
            ;;
    esac
    
    press_enter
}

#==============================================================================
# Complete Server Optimization
#==============================================================================

optimize_server() {
    print_header "COMPLETE SERVER OPTIMIZATION"
    
    echo -e "${YELLOW}This will apply comprehensive system optimizations${NC}"
    echo -e "${YELLOW}Including: Memory, Network, File System, and Security${NC}\n"
    echo -e "${RED}âš  WARNING: This will modify system configuration files${NC}\n"
    
    echo -ne "${YELLOW}Continue? [y/N]: ${NC}"
    read confirm
    if [[ ! $confirm =~ ^[Yy]$ ]]; then
        return
    fi
    
    echo ""
    print_status "INFO" "Backing up configuration files..."
    
    # Backup files
    backup_file "$SYSCTL_CONF"
    backup_file "/etc/security/limits.conf"
    
    # Create new sysctl.conf
    cat > "$SYSCTL_CONF" << 'EOF'
# Server Optimization Configuration
# Generated by Server Management Tool

# Memory Management
vm.swappiness=10
vm.dirty_ratio=20
vm.dirty_background_ratio=10

# File System
fs.file-max=2097152

# Network Core
net.core.somaxconn=4096
net.core.netdev_max_backlog=16384

# IPv4 Network
net.ipv4.ip_local_port_range=1024 65535
net.ipv4.ip_nonlocal_bind=1

# TCP Configuration
net.ipv4.tcp_fin_timeout=15
net.ipv4.tcp_keepalive_time=300
net.ipv4.tcp_syncookies=0
net.ipv4.tcp_max_orphans=262144
net.ipv4.tcp_max_syn_backlog=8192
net.ipv4.tcp_max_tw_buckets=262144
net.ipv4.tcp_reordering=3

# TCP Memory
net.ipv4.tcp_mem=786432 1697152 1945728
net.ipv4.tcp_rmem=4096 87380 16777216
net.ipv4.tcp_wmem=4096 65536 16777216

# TCP Retries
net.ipv4.tcp_syn_retries=5

# TCP Reuse
net.ipv4.tcp_tw_reuse=1
EOF
    
    print_status "OK" "Created new sysctl.conf"
    
    # Create new limits.conf
    cat > /etc/security/limits.conf << 'EOF'
# System Limits Configuration
# Generated by Server Management Tool

* soft nproc 65535
* hard nproc 65535
* soft nofile 1048576
* hard nofile 1048576

root soft nproc 65535
root hard nproc 65535
root soft nofile 1048576
root hard nofile 1048576
EOF
    
    print_status "OK" "Created new limits.conf"
    
    # Apply sysctl settings
    print_status "INFO" "Applying kernel parameters..."
    sysctl -p > /dev/null 2>&1
    
    print_status "OK" "System optimization completed!"
    echo ""
    echo -e "${CYAN}Applied optimizations:${NC}"
    echo -e "  ${GREEN}âœ“${NC} Memory management (swappiness, dirty ratio)"
    echo -e "  ${GREEN}âœ“${NC} File system limits (file-max)"
    echo -e "  ${GREEN}âœ“${NC} Network buffers and backlog"
    echo -e "  ${GREEN}âœ“${NC} TCP parameters (timeouts, memory)"
    echo -e "  ${GREEN}âœ“${NC} Process and file descriptor limits"
    echo ""
    print_status "INFO" "All settings will persist after reboot"
    print_status "INFO" "Backups saved in: $BACKUP_DIR"
    
    press_enter
}

#==============================================================================
# Server Monitoring
#==============================================================================

monitoring() {
   
   print_header "Server Monitoring"
    
   echo -e "${YELLOW}Running comprehensive benchmark...${NC}\n"
   echo -e "${CYAN}This may take a few minutes${NC}\n"
    
   apt install btop -y
   btop
    
   press_enter
}


#==============================================================================
# IP Reputation & Security Check
#==============================================================================

check_ip_reputation() {
    print_header "IP REPUTATION & SECURITY CHECK"
    
    # Get public IP
    echo -ne "${CYAN}Getting your public IP...${NC}\r"
    PUBLIC_IP=$(curl -s --max-time 5 https://api.ipify.org 2>/dev/null || echo "N/A")
    
    if [ "$PUBLIC_IP" = "N/A" ]; then
        print_status "FAIL" "Cannot get public IP address"
        press_enter
        return
    fi
    
    echo -e "${GREEN}âœ“${NC} Your Public IP: ${YELLOW}${BOLD}$PUBLIC_IP${NC}       \n"
    
    local total_checks=0
    local passed_checks=0
    local critical_issues=0
    
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"
    
    # 1. IP-API - Basic Info
    echo -e "${BOLD}[1/8] IP Geolocation & ISP${NC}"
    echo -ne "${GRAY}Checking...${NC}\r"
    
    ip_info=$(curl -s --max-time 5 "http://ip-api.com/json/$PUBLIC_IP?fields=status,country,city,isp,org,proxy,hosting" 2>/dev/null)
    
    if [ -n "$ip_info" ] && echo "$ip_info" | grep -q "success"; then
        country=$(echo "$ip_info" | grep -o '"country":"[^"]*' | cut -d'"' -f4)
        city=$(echo "$ip_info" | grep -o '"city":"[^"]*' | cut -d'"' -f4)
        isp=$(echo "$ip_info" | grep -o '"isp":"[^"]*' | cut -d'"' -f4)
        is_proxy=$(echo "$ip_info" | grep -o '"proxy":true' | wc -l)
        is_hosting=$(echo "$ip_info" | grep -o '"hosting":true' | wc -l)
        
        echo -e "${GREEN}âœ“${NC} Location: ${CYAN}$city, $country${NC}       "
        echo -e "${GREEN}âœ“${NC} ISP: ${CYAN}${isp:0:50}${NC}"
        
        total_checks=$((total_checks + 1))
        
        if [ $is_proxy -eq 0 ]; then
            passed_checks=$((passed_checks + 1))
            echo -e "${GREEN}âœ“${NC} Proxy: ${GREEN}Not detected${NC}"
        else
            echo -e "${RED}âœ—${NC} Proxy: ${RED}Detected${NC}"
            critical_issues=$((critical_issues + 1))
        fi
        
        [ $is_hosting -eq 1 ] && echo -e "${YELLOW}âš ${NC} Type: ${YELLOW}Hosting/VPS/Datacenter${NC}" || echo -e "${GREEN}âœ“${NC} Type: ${GREEN}Residential${NC}"
    else
        echo -e "${RED}âœ—${NC} Check failed       "
    fi
    echo ""
    
    # 2. IPQualityScore
    echo -e "${BOLD}[2/8] IPQualityScore - Fraud Detection${NC}"
    echo -ne "${GRAY}Checking...${NC}\r"
    
    ipqs=$(curl -s --max-time 5 "https://www.ipqualityscore.com/api/json/ip/free/$PUBLIC_IP" 2>/dev/null)
    
    if [ -n "$ipqs" ]; then
        fraud=$(echo "$ipqs" | grep -o '"fraud_score":[0-9]*' | cut -d':' -f2)
        vpn=$(echo "$ipqs" | grep -o '"vpn":true' | wc -l)
        proxy=$(echo "$ipqs" | grep -o '"proxy":true' | wc -l)
        tor=$(echo "$ipqs" | grep -o '"tor":true' | wc -l)
        
        total_checks=$((total_checks + 1))
        
        if [ -n "$fraud" ]; then
            if [ "$fraud" -lt 50 ]; then
                passed_checks=$((passed_checks + 1))
                echo -e "${GREEN}âœ“${NC} Fraud Score: ${GREEN}$fraud/100${NC} (Low)       "
            elif [ "$fraud" -lt 75 ]; then
                echo -e "${YELLOW}âš ${NC} Fraud Score: ${YELLOW}$fraud/100${NC} (Medium)"
            else
                echo -e "${RED}âœ—${NC} Fraud Score: ${RED}$fraud/100${NC} (High)"
                critical_issues=$((critical_issues + 1))
            fi
        fi
        
        [ $vpn -eq 0 ] && echo -e "${GREEN}âœ“${NC} VPN: ${GREEN}Not detected${NC}" || echo -e "${RED}âœ—${NC} VPN: ${RED}Detected${NC}"
        [ $proxy -eq 0 ] && echo -e "${GREEN}âœ“${NC} Proxy: ${GREEN}Not detected${NC}" || echo -e "${RED}âœ—${NC} Proxy: ${RED}Detected${NC}"
        [ $tor -eq 0 ] && echo -e "${GREEN}âœ“${NC} Tor: ${GREEN}Not detected${NC}" || echo -e "${RED}âœ—${NC} Tor: ${RED}Detected${NC}"
    else
        echo -e "${RED}âœ—${NC} Check failed       "
    fi
    echo ""
    
    # 3. Shodan
    echo -e "${BOLD}[3/8] Shodan - Port Scanner${NC}"
    echo -ne "${GRAY}Checking...${NC}\r"
    
    shodan=$(curl -s --max-time 5 "https://internetdb.shodan.io/$PUBLIC_IP" 2>/dev/null)
    
    if [ -n "$shodan" ] && ! echo "$shodan" | grep -q "No information"; then
        ports=$(echo "$shodan" | grep -o '"ports":\[[^]]*\]' | grep -o '[0-9]*' | tr '\n' ',' | sed 's/,$//')
        vulns=$(echo "$shodan" | grep -o '"vulns":\[[^]]*\]' | grep -o 'CVE-[0-9-]*' | wc -l)
        
        [ -n "$ports" ] && echo -e "${YELLOW}âš ${NC} Ports: ${YELLOW}$ports${NC}       " || echo -e "${GREEN}âœ“${NC} No common ports detected       "
        
        if [ "$vulns" -gt 0 ]; then
            echo -e "${RED}âœ—${NC} Vulnerabilities: ${RED}$vulns CVEs${NC}"
            critical_issues=$((critical_issues + 1))
        else
            echo -e "${GREEN}âœ“${NC} No known vulnerabilities       "
        fi
    else
        echo -e "${GREEN}âœ“${NC} No data (not heavily scanned)       "
    fi
    echo ""
    
    # 4. DNS Blacklists
    echo -e "${BOLD}[4/8] DNS Blacklists${NC}"
    echo -ne "${GRAY}Checking...${NC}\r"
    
    reversed_ip=$(echo "$PUBLIC_IP" | awk -F. '{print $4"."$3"."$2"."$1}')
    blacklisted=0
    bl_names=""
    
    for rbl in "zen.spamhaus.org" "bl.spamcop.net" "dnsbl.sorbs.net" "b.barracudacentral.org" "bl.spameatingmonkey.net" "dnsbl-1.uceprotect.net"; do
        if host "${reversed_ip}.${rbl}" &>/dev/null; then
            blacklisted=$((blacklisted + 1))
            bl_names="$bl_names$rbl "
        fi
    done
    
    total_checks=$((total_checks + 1))
    
    if [ $blacklisted -eq 0 ]; then
        passed_checks=$((passed_checks + 1))
        echo -e "${GREEN}âœ“${NC} Clean (0/6 lists)${NC}       "
    else
        echo -e "${RED}âœ—${NC} Listed in $blacklisted/6 lists${NC}"
        echo -e "  ${RED}$bl_names${NC}"
        critical_issues=$((critical_issues + 1))
    fi
    echo ""
    
    # 5. IPHub
    echo -e "${BOLD}[5/8] IPHub - Proxy Detection${NC}"
    echo -ne "${GRAY}Checking...${NC}\r"
    
    iphub=$(curl -s --max-time 5 "http://v2.api.iphub.info/ip/$PUBLIC_IP" 2>/dev/null)
    
    if [ -n "$iphub" ]; then
        block=$(echo "$iphub" | grep -o '"block":[0-2]' | cut -d':' -f2)
        total_checks=$((total_checks + 1))
        
        case "$block" in
            0)
                passed_checks=$((passed_checks + 1))
                echo -e "${GREEN}âœ“${NC} Residential/Business IP       "
                ;;
            1)
                echo -e "${RED}âœ—${NC} Proxy/VPN detected${NC}"
                critical_issues=$((critical_issues + 1))
                ;;
            2)
                echo -e "${YELLOW}âš ${NC} Hosting/Datacenter${NC}"
                ;;
            *)
                total_checks=$((total_checks - 1))
                echo -e "${YELLOW}âš ${NC} Unknown${NC}"
                ;;
        esac
    else
        echo -e "${YELLOW}âš ${NC} Check unavailable       "
    fi
    echo ""
    
    # 6. Scamalytics
    echo -e "${BOLD}[6/8] Scamalytics - Fraud${NC}"
    echo -ne "${GRAY}Checking...${NC}\r"
    
    scam=$(curl -s --max-time 5 "https://scamalytics.com/ip/$PUBLIC_IP" 2>/dev/null)
    
    if [ -n "$scam" ]; then
        fraud_scam=$(echo "$scam" | grep -o 'Fraud Score: [0-9]*' | grep -o '[0-9]*' | head -1)
        total_checks=$((total_checks + 1))
        
        if [ -n "$fraud_scam" ]; then
            if [ "$fraud_scam" -lt 25 ]; then
                passed_checks=$((passed_checks + 1))
                echo -e "${GREEN}âœ“${NC} Score: ${GREEN}$fraud_scam/100${NC} (Very Low)       "
            elif [ "$fraud_scam" -lt 75 ]; then
                echo -e "${YELLOW}âš ${NC} Score: ${YELLOW}$fraud_scam/100${NC}"
            else
                echo -e "${RED}âœ—${NC} Score: ${RED}$fraud_scam/100${NC} (High)"
                critical_issues=$((critical_issues + 1))
            fi
        else
            total_checks=$((total_checks - 1))
            echo -e "${YELLOW}âš ${NC} Could not parse       "
        fi
    else
        echo -e "${YELLOW}âš ${NC} Check failed       "
    fi
    echo ""
    
    # 7. GetIPIntel
    echo -e "${BOLD}[7/8] GetIPIntel - Proxy Probability${NC}"
    echo -ne "${GRAY}Checking...${NC}\r"
    
    getip=$(curl -s --max-time 5 "http://check.getipintel.net/check.php?ip=$PUBLIC_IP&contact=admin@server.local&flags=b" 2>/dev/null)
    
    if [ -n "$getip" ] && [ "$getip" != "-1" ] && [ "$getip" != "-2" ]; then
        prob=$(echo "$getip" | awk '{printf "%.0f", $1 * 100}')
        total_checks=$((total_checks + 1))
        
        if [ "$prob" -lt 50 ]; then
            passed_checks=$((passed_checks + 1))
            echo -e "${GREEN}âœ“${NC} Probability: ${GREEN}${prob}%${NC} (Low)       "
        elif [ "$prob" -lt 75 ]; then
            echo -e "${YELLOW}âš ${NC} Probability: ${YELLOW}${prob}%${NC}"
        else
            echo -e "${RED}âœ—${NC} Probability: ${RED}${prob}%${NC} (High)"
            critical_issues=$((critical_issues + 1))
        fi
    else
        echo -e "${YELLOW}âš ${NC} Check unavailable       "
    fi
    echo ""
    
    # 8. AbuseIPDB
    echo -e "${BOLD}[8/8] AbuseIPDB${NC}"
    echo -ne "${GRAY}Checking...${NC}\r"
    
    abuse_page=$(curl -s --max-time 5 "https://www.abuseipdb.com/check/$PUBLIC_IP" 2>/dev/null)
    total_checks=$((total_checks + 1))
    
    if echo "$abuse_page" | grep -qi "whitelisted\|not found\|clean\|0 reports"; then
        passed_checks=$((passed_checks + 1))
        echo -e "${GREEN}âœ“${NC} No abuse reports${NC}       "
    elif echo "$abuse_page" | grep -qi "reported\|blacklist"; then
        echo -e "${RED}âœ—${NC} Abuse reports found${NC}"
        critical_issues=$((critical_issues + 1))
    else
        echo -e "${YELLOW}âš ${NC} Could not verify${NC}"
        total_checks=$((total_checks - 1))
    fi
    echo ""
    
    # Final Score
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"
    
    [ $total_checks -eq 0 ] && total_checks=1
    score=$((passed_checks * 100 / total_checks))
    
    echo -e "${BOLD}FINAL REPUTATION SCORE:${NC}\n"
    
    # Progress bar
    filled=$((score / 2))
    empty=$((50 - filled))
    
    if [ $score -ge 80 ]; then
        color="${GREEN}"
        status="CLEAN IP âœ“"
    elif [ $score -ge 60 ]; then
        color="${YELLOW}"
        status="MODERATE"
    else
        color="${RED}"
        status="DIRTY IP âœ—"
    fi
    
    echo -ne "${color}"
    printf 'â–ˆ%.0s' $(seq 1 $filled)
    echo -ne "${GRAY}"
    printf 'â–‘%.0s' $(seq 1 $empty)
    echo -e "${NC} ${BOLD}${score}%${NC}"
    echo ""
    
    echo -e "${BOLD}Status: ${color}$status${NC}"
    echo -e "Passed: ${GREEN}$passed_checks${NC}/${CYAN}$total_checks${NC}"
    [ $critical_issues -gt 0 ] && echo -e "Critical: ${RED}$critical_issues${NC}"
    echo ""
    
    if [ $score -lt 80 ]; then
        echo -e "${YELLOW}${BOLD}RECOMMENDATIONS:${NC}"
        [ $critical_issues -gt 0 ] && echo -e "${RED}âš ${NC} Consider getting a new IP"
        echo -e "${CYAN}Detailed check:${NC}"
        echo -e "â€¢ ${BLUE}https://scamalytics.com/ip/$PUBLIC_IP${NC}"
        echo -e "â€¢ ${BLUE}https://www.abuseipdb.com/check/$PUBLIC_IP${NC}"
    fi
    
    echo ""
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    
    press_enter
}

#==============================================================================
# Service & Log Management
#==============================================================================

check_service_status() {
    local service=$1
    local display_name=$2
    
    if systemctl list-units --full -all | grep -Fq "$service"; then
        if systemctl is-active --quiet "$service"; then
            echo -e "${GREEN}âœ“${NC} $display_name: ${GREEN}Running${NC}"
            return 0
        else
            echo -e "${RED}âœ—${NC} $display_name: ${RED}Stopped${NC}"
            return 1
        fi
    else
        echo -e "${GRAY}â—‹${NC} $display_name: ${GRAY}Not installed${NC}"
        return 2
    fi
}

view_service_logs() {
    local service=$1
    local display_name=$2
    local lines=${3:-50}
    
    print_header "$display_name LOGS (Last $lines lines)"
    
    if systemctl list-units --full -all | grep -Fq "$service"; then
        echo -e "${CYAN}${BOLD}Service Status:${NC}"
        systemctl status "$service" --no-pager -l | head -15
        echo ""
        echo -e "${CYAN}${BOLD}Recent Logs:${NC}\n"
        journalctl -u "$service" -n "$lines" --no-pager | tail -50
    else
        print_status "WARN" "$display_name is not installed"
    fi
    
    press_enter
}

view_error_logs() {
    local service=$1
    local display_name=$2
    local lines=${3:-50}
    
    print_header "$display_name ERROR LOGS"
    
    if systemctl list-units --full -all | grep -Fq "$service"; then
        echo -e "${RED}${BOLD}Errors and Warnings:${NC}\n"
        journalctl -u "$service" -p err..warning -n "$lines" --no-pager | tail -50
        
        if [ -z "$(journalctl -u "$service" -p err..warning -n 1 --no-pager 2>/dev/null)" ]; then
            echo -e "${GREEN}âœ“ No errors found in recent logs${NC}"
        fi
    else
        print_status "WARN" "$display_name is not installed"
    fi
    
    press_enter
}

manage_php_fpm() {
    while true; do
        print_header "PHP-FPM MANAGEMENT"
        
        # Detect PHP-FPM versions
        local php_versions=()
        for ver in 8.4 8.3 8.2 8.1 8.0 7.4 7.3 7.2; do
            if systemctl list-units --full -all | grep -Fq "php${ver}-fpm"; then
                php_versions+=("php${ver}-fpm")
            fi
        done
        
        if [ ${#php_versions[@]} -eq 0 ]; then
            print_status "WARN" "No PHP-FPM services found"
            press_enter
            return
        fi
        
        echo -e "${CYAN}${BOLD}Installed PHP-FPM versions:${NC}\n"
        
        for php_service in "${php_versions[@]}"; do
            check_service_status "$php_service" "$php_service"
        done
        
        echo ""
        echo "  1) View PHP-FPM Logs"
        echo "  2) View PHP-FPM Error Logs"
        echo "  3) Restart PHP-FPM"
        echo "  4) Check PHP-FPM Status"
        echo "  5) View PHP-FPM Pool Configuration"
        echo "  0) Back"
        echo ""
        read -p "Choice: " choice
        
        case $choice in
            1)
                if [ ${#php_versions[@]} -eq 1 ]; then
                    view_service_logs "${php_versions[0]}" "PHP-FPM"
                else
                    echo ""
                    echo -e "${CYAN}Select PHP version:${NC}"
                    select php_service in "${php_versions[@]}"; do
                        [ -n "$php_service" ] && view_service_logs "$php_service" "$php_service" && break
                    done
                fi
                ;;
            2)
                if [ ${#php_versions[@]} -eq 1 ]; then
                    view_error_logs "${php_versions[0]}" "PHP-FPM"
                else
                    echo ""
                    echo -e "${CYAN}Select PHP version:${NC}"
                    select php_service in "${php_versions[@]}"; do
                        [ -n "$php_service" ] && view_error_logs "$php_service" "$php_service" && break
                    done
                fi
                ;;
            3)
                if [ ${#php_versions[@]} -eq 1 ]; then
                    systemctl restart "${php_versions[0]}"
                    print_status "OK" "PHP-FPM restarted"
                else
                    echo ""
                    echo -e "${CYAN}Select PHP version to restart:${NC}"
                    select php_service in "${php_versions[@]}" "All"; do
                        if [ "$php_service" = "All" ]; then
                            for svc in "${php_versions[@]}"; do
                                systemctl restart "$svc"
                                print_status "OK" "$svc restarted"
                            done
                        elif [ -n "$php_service" ]; then
                            systemctl restart "$php_service"
                            print_status "OK" "$php_service restarted"
                        fi
                        break
                    done
                fi
                press_enter
                ;;
            4)
                print_header "PHP-FPM STATUS"
                for php_service in "${php_versions[@]}"; do
                    echo -e "\n${CYAN}${BOLD}=== $php_service ===${NC}\n"
                    systemctl status "$php_service" --no-pager -l
                done
                press_enter
                ;;
            5)
                print_header "PHP-FPM POOL CONFIGURATION"
                for php_service in "${php_versions[@]}"; do
                    version=$(echo "$php_service" | grep -oP '\d+\.\d+')
                    pool_dir="/etc/php/$version/fpm/pool.d"
                    
                    if [ -d "$pool_dir" ]; then
                        echo -e "${CYAN}${BOLD}=== PHP $version Pools ===${NC}\n"
                        ls -1 "$pool_dir"/*.conf 2>/dev/null | while read conf; do
                            echo -e "${GREEN}$(basename $conf)${NC}"
                        done
                        echo ""
                    fi
                done
                press_enter
                ;;
            0)
                return
                ;;
            *)
                print_status "FAIL" "Invalid choice"
                sleep 1
                ;;
        esac
    done
}

manage_nginx() {
    while true; do
        print_header "NGINX MANAGEMENT"
        
        check_service_status "nginx" "Nginx"
        
        echo ""
        echo "  1) View Nginx Access Logs"
        echo "  2) View Nginx Error Logs"
        echo "  3) Restart Nginx"
        echo "  4) Test Nginx Configuration"
        echo "  5) View Nginx Status"
        echo "  6) View Active Connections"
        echo "  0) Back"
        echo ""
        read -p "Choice: " choice
        
        case $choice in
            1)
                print_header "NGINX ACCESS LOGS"
                if [ -f /var/log/nginx/access.log ]; then
                    tail -50 /var/log/nginx/access.log
                else
                    print_status "WARN" "Access log not found"
                fi
                press_enter
                ;;
            2)
                print_header "NGINX ERROR LOGS"
                if [ -f /var/log/nginx/error.log ]; then
                    tail -50 /var/log/nginx/error.log
                    
                    if [ ! -s /var/log/nginx/error.log ]; then
                        echo -e "${GREEN}âœ“ No errors in log${NC}"
                    fi
                else
                    print_status "WARN" "Error log not found"
                fi
                press_enter
                ;;
            3)
                nginx -t &>/dev/null
                if [ $? -eq 0 ]; then
                    systemctl restart nginx
                    print_status "OK" "Nginx restarted successfully"
                else
                    print_status "FAIL" "Configuration test failed. Not restarting."
                    nginx -t
                fi
                press_enter
                ;;
            4)
                print_header "NGINX CONFIGURATION TEST"
                nginx -t
                press_enter
                ;;
            5)
                view_service_logs "nginx" "Nginx"
                ;;
            6)
                print_header "NGINX ACTIVE CONNECTIONS"
                if command -v ss &>/dev/null; then
                    echo -e "${CYAN}Listening on:${NC}"
                    ss -tlnp | grep nginx
                    echo ""
                    echo -e "${CYAN}Connection Statistics:${NC}"
                    ss -s
                else
                    netstat -tlnp | grep nginx
                fi
                press_enter
                ;;
            0)
                return
                ;;
            *)
                print_status "FAIL" "Invalid choice"
                sleep 1
                ;;
        esac
    done
}

manage_apache() {
    while true; do
        print_header "APACHE MANAGEMENT"
        
        # Check both apache2 and httpd
        local apache_service=""
        if systemctl list-units --full -all | grep -Fq "apache2"; then
            apache_service="apache2"
        elif systemctl list-units --full -all | grep -Fq "httpd"; then
            apache_service="httpd"
        fi
        
        if [ -z "$apache_service" ]; then
            print_status "WARN" "Apache is not installed"
            press_enter
            return
        fi
        
        check_service_status "$apache_service" "Apache"
        
        echo ""
        echo "  1) View Apache Access Logs"
        echo "  2) View Apache Error Logs"
        echo "  3) Restart Apache"
        echo "  4) Test Apache Configuration"
        echo "  5) View Apache Status"
        echo "  6) View Loaded Modules"
        echo "  0) Back"
        echo ""
        read -p "Choice: " choice
        
        case $choice in
            1)
                print_header "APACHE ACCESS LOGS"
                if [ -f /var/log/apache2/access.log ]; then
                    tail -50 /var/log/apache2/access.log
                elif [ -f /var/log/httpd/access_log ]; then
                    tail -50 /var/log/httpd/access_log
                else
                    print_status "WARN" "Access log not found"
                fi
                press_enter
                ;;
            2)
                print_header "APACHE ERROR LOGS"
                if [ -f /var/log/apache2/error.log ]; then
                    tail -50 /var/log/apache2/error.log
                elif [ -f /var/log/httpd/error_log ]; then
                    tail -50 /var/log/httpd/error_log
                else
                    print_status "WARN" "Error log not found"
                fi
                press_enter
                ;;
            3)
                if command -v apachectl &>/dev/null; then
                    apachectl configtest &>/dev/null
                    if [ $? -eq 0 ]; then
                        systemctl restart "$apache_service"
                        print_status "OK" "Apache restarted successfully"
                    else
                        print_status "FAIL" "Configuration test failed"
                        apachectl configtest
                    fi
                else
                    systemctl restart "$apache_service"
                    print_status "OK" "Apache restarted"
                fi
                press_enter
                ;;
            4)
                print_header "APACHE CONFIGURATION TEST"
                if command -v apachectl &>/dev/null; then
                    apachectl configtest
                else
                    print_status "WARN" "apachectl not found"
                fi
                press_enter
                ;;
            5)
                view_service_logs "$apache_service" "Apache"
                ;;
            6)
                print_header "APACHE LOADED MODULES"
                if command -v apachectl &>/dev/null; then
                    apachectl -M
                elif command -v apache2ctl &>/dev/null; then
                    apache2ctl -M
                else
                    print_status "WARN" "Cannot list modules"
                fi
                press_enter
                ;;
            0)
                return
                ;;
            *)
                print_status "FAIL" "Invalid choice"
                sleep 1
                ;;
        esac
    done
}

manage_mysql() {
    while true; do
        print_header "MYSQL/MARIADB MANAGEMENT"
        
        local mysql_service=""
        if systemctl list-units --full -all | grep -Fq "mysql"; then
            mysql_service="mysql"
        elif systemctl list-units --full -all | grep -Fq "mariadb"; then
            mysql_service="mariadb"
        fi
        
        if [ -z "$mysql_service" ]; then
            print_status "WARN" "MySQL/MariaDB is not installed"
            press_enter
            return
        fi
        
        check_service_status "$mysql_service" "MySQL/MariaDB"
        
        echo ""
        echo "  1) View MySQL Logs"
        echo "  2) View MySQL Error Logs"
        echo "  3) Restart MySQL"
        echo "  4) View MySQL Status"
        echo "  5) Show MySQL Processes"
        echo "  6) Check MySQL Variables"
        echo "  0) Back"
        echo ""
        read -p "Choice: " choice
        
        case $choice in
            1)
                view_service_logs "$mysql_service" "MySQL"
                ;;
            2)
                print_header "MYSQL ERROR LOGS"
                if [ -f /var/log/mysql/error.log ]; then
                    tail -50 /var/log/mysql/error.log
                elif [ -f /var/log/mysqld.log ]; then
                    tail -50 /var/log/mysqld.log
                else
                    journalctl -u "$mysql_service" -p err -n 50 --no-pager
                fi
                press_enter
                ;;
            3)
                systemctl restart "$mysql_service"
                print_status "OK" "MySQL restarted"
                press_enter
                ;;
            4)
                view_service_logs "$mysql_service" "MySQL"
                ;;
            5)
                print_header "MYSQL PROCESSES"
                if command -v mysql &>/dev/null; then
                    mysql -e "SHOW PROCESSLIST;" 2>/dev/null || print_status "WARN" "Cannot connect to MySQL"
                else
                    print_status "WARN" "MySQL client not found"
                fi
                press_enter
                ;;
            6)
                print_header "MYSQL KEY VARIABLES"
                if command -v mysql &>/dev/null; then
                    mysql -e "SHOW VARIABLES LIKE '%max_connections%'; SHOW VARIABLES LIKE '%buffer%';" 2>/dev/null | head -20
                else
                    print_status "WARN" "MySQL client not found"
                fi
                press_enter
                ;;
            0)
                return
                ;;
            *)
                print_status "FAIL" "Invalid choice"
                sleep 1
                ;;
        esac
    done
}

manage_redis() {
    while true; do
        print_header "REDIS MANAGEMENT"
        
        local redis_service=""
        if systemctl list-units --full -all | grep -Fq "redis-server"; then
            redis_service="redis-server"
        elif systemctl list-units --full -all | grep -Fq "redis"; then
            redis_service="redis"
        fi
        
        if [ -z "$redis_service" ]; then
            print_status "WARN" "Redis is not installed"
            press_enter
            return
        fi
        
        check_service_status "$redis_service" "Redis"
        
        echo ""
        echo "  1) View Redis Logs"
        echo "  2) Restart Redis"
        echo "  3) View Redis Status"
        echo "  4) Check Redis Info"
        echo "  5) Monitor Redis"
        echo "  0) Back"
        echo ""
        read -p "Choice: " choice
        
        case $choice in
            1)
                view_service_logs "$redis_service" "Redis"
                ;;
            2)
                systemctl restart "$redis_service"
                print_status "OK" "Redis restarted"
                press_enter
                ;;
            3)
                view_service_logs "$redis_service" "Redis"
                ;;
            4)
                print_header "REDIS INFO"
                if command -v redis-cli &>/dev/null; then
                    redis-cli INFO | head -50
                else
                    print_status "WARN" "redis-cli not found"
                fi
                press_enter
                ;;
            5)
                print_header "REDIS MONITOR (Press Ctrl+C to stop)"
                echo ""
                if command -v redis-cli &>/dev/null; then
                    timeout 10 redis-cli MONITOR || print_status "INFO" "Monitoring stopped"
                else
                    print_status "WARN" "redis-cli not found"
                fi
                press_enter
                ;;
            0)
                return
                ;;
            *)
                print_status "FAIL" "Invalid choice"
                sleep 1
                ;;
        esac
    done
}

manage_docker() {
    while true; do
        print_header "DOCKER MANAGEMENT"
        
        if ! command -v docker &>/dev/null; then
            print_status "WARN" "Docker is not installed"
            press_enter
            return
        fi
        
        check_service_status "docker" "Docker"
        
        echo ""
        echo "  1) List Running Containers"
        echo "  2) List All Containers"
        echo "  3) View Container Logs"
        echo "  4) View Docker Images"
        echo "  5) Docker System Info"
        echo "  6) Docker Stats (Live)"
        echo "  7) View Failed Container Logs"
        echo "  0) Back"
        echo ""
        read -p "Choice: " choice
        
        case $choice in
            1)
                print_header "RUNNING CONTAINERS"
                docker ps
                press_enter
                ;;
            2)
                print_header "ALL CONTAINERS"
                docker ps -a
                press_enter
                ;;
            3)
                print_header "CONTAINER LOGS"
                echo ""
                docker ps -a --format "{{.Names}}" | nl
                echo ""
                read -p "Enter container name or number: " container
                
                if [[ "$container" =~ ^[0-9]+$ ]]; then
                    container=$(docker ps -a --format "{{.Names}}" | sed -n "${container}p")
                fi
                
                if [ -n "$container" ]; then
                    echo ""
                    print_header "LOGS: $container"
                    docker logs --tail 100 "$container" 2>&1
                fi
                press_enter
                ;;
            4)
                print_header "DOCKER IMAGES"
                docker images
                press_enter
                ;;
            5)
                print_header "DOCKER SYSTEM INFO"
                docker info
                press_enter
                ;;
            6)
                print_header "DOCKER STATS (Press Ctrl+C to stop)"
                echo ""
                docker stats
                press_enter
                ;;
            7)
                print_header "FAILED/EXITED CONTAINERS"
                docker ps -a --filter "status=exited" --format "table {{.Names}}\t{{.Status}}\t{{.Image}}"
                echo ""
                echo -e "${CYAN}Recent error logs:${NC}\n"
                docker ps -a --filter "status=exited" --format "{{.Names}}" | while read container; do
                    echo -e "${RED}=== $container ===${NC}"
                    docker logs --tail 20 "$container" 2>&1 | grep -i error | head -5
                    echo ""
                done
                press_enter
                ;;
            0)
                return
                ;;
            *)
                print_status "FAIL" "Invalid choice"
                sleep 1
                ;;
        esac
    done
}

service_log_menu() {
    while true; do
        print_banner
        print_header "SERVICE & LOG MANAGEMENT"
        
        echo -e "${CYAN}${BOLD}Service Status Overview:${NC}\\n"
        
        # Track services and errors
        local total_errors=0
        
        # Nginx
        check_service_status "nginx" "Nginx"
        if systemctl is-active --quiet nginx 2>/dev/null; then
            local nginx_errors=$(journalctl -u nginx -p err --since "1 hour ago" --no-pager 2>/dev/null | grep -vE "^(--|\\s*$)" | wc -l)
            if [ "$nginx_errors" -gt 0 ]; then
                echo -e "  ${RED}âš  $nginx_errors error(s) in last hour${NC}"
                total_errors=$((total_errors + nginx_errors))
            fi
        fi
        
        # Apache
        if systemctl list-units --full -all | grep -Fq "apache2"; then
            check_service_status "apache2" "Apache"
            if systemctl is-active --quiet apache2 2>/dev/null; then
                local apache_errors=$(journalctl -u apache2 -p err --since "1 hour ago" --no-pager 2>/dev/null | grep -vE "^(--|\\s*$)" | wc -l)
                if [ "$apache_errors" -gt 0 ]; then
                    echo -e "  ${RED}âš  $apache_errors error(s) in last hour${NC}"
                    total_errors=$((total_errors + apache_errors))
                fi
            fi
        elif systemctl list-units --full -all | grep -Fq "httpd"; then
            check_service_status "httpd" "Apache"
            if systemctl is-active --quiet httpd 2>/dev/null; then
                local httpd_errors=$(journalctl -u httpd -p err --since "1 hour ago" --no-pager 2>/dev/null | grep -vE "^(--|\\s*$)" | wc -l)
                if [ "$httpd_errors" -gt 0 ]; then
                    echo -e "  ${RED}âš  $httpd_errors error(s) in last hour${NC}"
                    total_errors=$((total_errors + httpd_errors))
                fi
            fi
        else
            echo -e "${GRAY}â—‹${NC} Apache: ${GRAY}Not installed${NC}"
        fi
        
        # PHP-FPM - Check all versions
        local php_found=0
        for ver in 8.4 8.3 8.2 8.1 8.0 7.4 7.3 7.2; do
            if systemctl list-units --full -all | grep -Fq "php${ver}-fpm"; then
                check_service_status "php${ver}-fpm" "PHP ${ver}-FPM"
                php_found=1
                if systemctl is-active --quiet "php${ver}-fpm" 2>/dev/null; then
                    local php_errors=$(journalctl -u "php${ver}-fpm" -p err --since "1 hour ago" --no-pager 2>/dev/null | grep -vE "^(--|\\s*$)" | wc -l)
                    if [ "$php_errors" -gt 0 ]; then
                        echo -e "  ${RED}âš  $php_errors error(s) in last hour${NC}"
                        total_errors=$((total_errors + php_errors))
                    fi
                fi
            fi
        done
        [ $php_found -eq 0 ] && echo -e "${GRAY}â—‹${NC} PHP-FPM: ${GRAY}Not installed${NC}"
        
        # MySQL/MariaDB
        if systemctl list-units --full -all | grep -Fq "mysql"; then
            check_service_status "mysql" "MySQL"
            if systemctl is-active --quiet mysql 2>/dev/null; then
                local mysql_errors=$(journalctl -u mysql -p err --since "1 hour ago" --no-pager 2>/dev/null | grep -vE "^(--|\\s*$)" | wc -l)
                if [ "$mysql_errors" -gt 0 ]; then
                    echo -e "  ${RED}âš  $mysql_errors error(s) in last hour${NC}"
                    total_errors=$((total_errors + mysql_errors))
                fi
            fi
        elif systemctl list-units --full -all | grep -Fq "mariadb"; then
            check_service_status "mariadb" "MariaDB"
            if systemctl is-active --quiet mariadb 2>/dev/null; then
                local mariadb_errors=$(journalctl -u mariadb -p err --since "1 hour ago" --no-pager 2>/dev/null | grep -vE "^(--|\\s*$)" | wc -l)
                if [ "$mariadb_errors" -gt 0 ]; then
                    echo -e "  ${RED}âš  $mariadb_errors error(s) in last hour${NC}"
                    total_errors=$((total_errors + mariadb_errors))
                fi
            fi
        else
            echo -e "${GRAY}â—‹${NC} MySQL/MariaDB: ${GRAY}Not installed${NC}"
        fi
        
        # Redis
        if systemctl list-units --full -all | grep -Fq "redis-server"; then
            check_service_status "redis-server" "Redis"
            if systemctl is-active --quiet redis-server 2>/dev/null; then
                local redis_errors=$(journalctl -u redis-server -p err --since "1 hour ago" --no-pager 2>/dev/null | grep -vE "^(--|\\s*$)" | wc -l)
                if [ "$redis_errors" -gt 0 ]; then
                    echo -e "  ${RED}âš  $redis_errors error(s) in last hour${NC}"
                    total_errors=$((total_errors + redis_errors))
                fi
            fi
        elif systemctl list-units --full -all | grep -Fq "redis"; then
            check_service_status "redis" "Redis"
            if systemctl is-active --quiet redis 2>/dev/null; then
                local redis_errors=$(journalctl -u redis -p err --since "1 hour ago" --no-pager 2>/dev/null | grep -vE "^(--|\\s*$)" | wc -l)
                if [ "$redis_errors" -gt 0 ]; then
                    echo -e "  ${RED}âš  $redis_errors error(s) in last hour${NC}"
                    total_errors=$((total_errors + redis_errors))
                fi
            fi
        else
            echo -e "${GRAY}â—‹${NC} Redis: ${GRAY}Not installed${NC}"
        fi
        
        # Docker
        check_service_status "docker" "Docker"
        if systemctl is-active --quiet docker 2>/dev/null; then
            local docker_errors=$(journalctl -u docker -p err --since "1 hour ago" --no-pager 2>/dev/null | grep -vE "^(--|\\s*$)" | wc -l)
            if [ "$docker_errors" -gt 0 ]; then
                echo -e "  ${RED}âš  $docker_errors error(s) in last hour${NC}"
                total_errors=$((total_errors + docker_errors))
            fi
        fi
        
        # Overall Status
        echo ""
        if [ $total_errors -eq 0 ]; then
            echo -e "${GREEN}${BOLD}âœ“ System Status: All services running without errors${NC}"
        else
            echo -e "${RED}${BOLD}âš  Total Errors (last hour): $total_errors${NC}"
            echo -e "${YELLOW}   Tip: Use option 8 to clear all logs${NC}"
        fi
        
        echo ""
        echo -e "${WHITE} 1)${NC} ðŸ”§ Nginx Management"
        echo -e "${WHITE} 2)${NC} ðŸ”§ Apache Management"
        echo -e "${WHITE} 3)${NC} ðŸ˜ PHP-FPM Management"
        echo -e "${WHITE} 4)${NC} ðŸ—„ï¸  MySQL/MariaDB Management"
        echo -e "${WHITE} 5)${NC} ðŸ”´ Redis Management"
        echo -e "${WHITE} 6)${NC} ðŸ³ Docker Management"
        echo -e "${WHITE} 7)${NC} ðŸ“Š System Logs (journalctl)"
        echo -e "${WHITE} 8)${NC} ðŸ—‘ï¸  Clear All Service Logs"
        echo -e "${WHITE} 0)${NC} â† Back to Main Menu"
        echo ""
        echo -ne "${YELLOW}Select option: ${NC}"
        read choice
        
        case $choice in
            1) manage_nginx ;;
            2) manage_apache ;;
            3) manage_php_fpm ;;
            4) manage_mysql ;;
            5) manage_redis ;;
            6) manage_docker ;;
            7)
                print_header "SYSTEM LOGS"
                echo "  1) View last 100 system logs"
                echo "  2) View system errors only"
                echo "  3) View logs since last boot"
                echo "  0) Back"
                echo ""
                read -p "Choice: " log_choice
                
                case $log_choice in
                    1)
                        print_header "LAST 100 SYSTEM LOGS"
                        journalctl -n 100 --no-pager
                        press_enter
                        ;;
                    2)
                        print_header "SYSTEM ERRORS"
                        journalctl -p err -n 50 --no-pager
                        press_enter
                        ;;
                    3)
                        print_header "LOGS SINCE BOOT"
                        journalctl -b --no-pager | tail -100
                        press_enter
                        ;;
                esac
                ;;
            8)
                print_header "CLEAR ALL SERVICE LOGS"
                echo -e "${YELLOW}This will clear ALL service logs and journal entries${NC}"
                echo -e "${RED}âš  This action cannot be undone!${NC}\n"
                echo -ne "${RED}Are you sure? [y/N]: ${NC}"
                read confirm
                
                if [[ $confirm =~ ^[Yy]$ ]]; then
                    echo ""
                    print_status "INFO" "Starting log cleanup..."
                    echo ""
                    
                    # Rotate journal first
                    journalctl --rotate 2>/dev/null
                    
                    # Clear all service journals in one command
                    journalctl --vacuum-time=1s >/dev/null 2>&1
                    
                    # Clear common log files
                    for log_file in \
                        /var/log/nginx/*.log \
                        /var/log/apache2/*.log \
                        /var/log/httpd/*.log \
                        /var/log/php*.log \
                        /var/log/mysql/*.log \
                        /var/log/mariadb/*.log \
                        /var/log/redis/*.log; do
                        [ -f "$log_file" ] && > "$log_file" 2>/dev/null
                    done
                    
                    # Force sync to disk
                    sync
                    systemctl daemon-reload 2>/dev/null
                    
                    print_status "OK" "All logs and journal entries cleared!"
                    
                    echo ""
                    echo -e "${CYAN}Journal disk usage:${NC}"
                    journalctl --disk-usage
                    echo ""
                    
                    press_enter
                fi
                ;;
            0) break ;;
            *) print_status "FAIL" "Invalid option"; sleep 1 ;;
        esac
    done
}

#==============================================================================
# Network Optimization Menu
#==============================================================================

network_optimization_menu() {
    while true; do
        print_banner
        show_system_info
        print_header "NETWORK & SERVER OPTIMIZATION"
        
        echo -e "${WHITE} 1)${NC} Install BBR (TCP Congestion Control)"
        echo -e "${WHITE} 2)${NC} Install Hybla (TCP for High Latency)"
        echo -e "${WHITE} 3)${NC} Remove TCP Optimization (BBR/Hybla)"
        echo -e "${WHITE} 4)${NC} MTU Finder + Auto Set"
        echo -e "${WHITE} 5)${NC} DNS Optimizer (Find & Set Fastest)"
        echo -e "${WHITE} 6)${NC} Block/Unblock Server Ping"
        echo -e "${WHITE} 7)${NC} ${BOLD}Complete Server Optimization${NC} ${CYAN}(Memory, TCP, Limits)${NC}"
        echo -e "${WHITE} 0)${NC} â† Back to Main Menu"
        echo ""
        echo -ne "${YELLOW}Select option: ${NC}"
        read choice
        
        case $choice in
            1) install_bbr ;;
            2) install_hybla ;;
            3) remove_tcp_optimization ;;
            4) mtu_finder ;;
            5) optimize_dns ;;
            6) manage_ping ;;
            7) optimize_server ;;
            0) break ;;
            *) print_status "FAIL" "Invalid option"; sleep 1 ;;
        esac
    done
}

#==============================================================================
# Repository Mirror Optimizer
#==============================================================================

optimize_mirrors() {
    print_header "OPTIMIZE APT MIRRORS"
    
    if [ "$OS" != "ubuntu" ] && [ "$OS" != "debian" ]; then
        print_status "FAIL" "This feature only works on Ubuntu/Debian"
        press_enter
        return
    fi
    
    echo -e "${YELLOW}Finding fastest mirrors for your server...${NC}\n"
    
    # Backup sources
    backup_file "/etc/apt/sources.list"
    [ -f "/etc/apt/sources.list.d/ubuntu.sources" ] && backup_file "/etc/apt/sources.list.d/ubuntu.sources"
    
    # Iranian Mirrors (with correct paths)
    declare -A IRAN_MIRRORS=(
        ["mirror.iranserver.com"]="mirror.iranserver.com/ubuntu"
        ["ir.ubuntu.sindad.cloud"]="ir.ubuntu.sindad.cloud/ubuntu"
        ["mirror.arvancloud.ir"]="mirror.arvancloud.ir/ubuntu"
        ["archive.ubuntu.petiak.ir"]="archive.ubuntu.petiak.ir/ubuntu"
        ["ubuntu.hostiran.ir"]="ubuntu.hostiran.ir/ubuntu"
        ["mirrors.pardisco.co"]="mirrors.pardisco.co/ubuntu"
        ["ubuntu.pars.host"]="ubuntu.pars.host/ubuntu"
        ["mirror.0-1.cloud"]="mirror.0-1.cloud/ubuntu"
        ["ubuntu.shatel.ir"]="ubuntu.shatel.ir/ubuntu"
        ["mirror.faraso.org"]="mirror.faraso.org/ubuntu"
        ["repo.linuxmirrors.ir"]="repo.linuxmirrors.ir/ubuntu"
    )
    
    # International Mirrors (with correct paths)
    declare -A INTL_MIRRORS=(
        ["archive.ubuntu.com"]="archive.ubuntu.com/ubuntu"
        ["mirrors.edge.kernel.org"]="mirrors.edge.kernel.org/ubuntu"
        ["mirror.math.princeton.edu"]="mirror.math.princeton.edu/pub/ubuntu"
        ["mirror.csclub.uwaterloo.ca"]="mirror.csclub.uwaterloo.ca/ubuntu"
        ["ftp.fau.de"]="ftp.fau.de/ubuntu"
        ["ftp.halifax.rwth-aachen.de"]="ftp.halifax.rwth-aachen.de/ubuntu"
        ["ftp.uni-stuttgart.de"]="ftp.uni-stuttgart.de/ubuntu"
        ["mirror.netcologne.de"]="mirror.netcologne.de/ubuntu"
        ["ftp.tu-chemnitz.de"]="ftp.tu-chemnitz.de/pub/linux/ubuntu"
        ["mirror.leaseweb.com"]="mirror.leaseweb.com/ubuntu"
        ["ubuntu.mirror.liquidtelecom.com"]="ubuntu.mirror.liquidtelecom.com/ubuntu"
        ["mirrors.digitalocean.com"]="mirrors.digitalocean.com/ubuntu"
    )
    
    declare -A iran_times
    declare -A intl_times
    
    # Test Iranian Mirrors
    echo -e "${CYAN}${BOLD}Testing Iranian Mirrors...${NC}\n"
    
    for mirror in "${!IRAN_MIRRORS[@]}"; do
        echo -ne "${GRAY}Testing $mirror...${NC}\r"
        
        ping_time=$(ping -c 2 -W 2 $mirror 2>/dev/null | grep rtt | awk -F'/' '{print $5}' | cut -d. -f1)
        
        if [ -n "$ping_time" ] && [ "$ping_time" -gt 0 ]; then
            iran_times["$mirror"]="$ping_time"
            echo -e "${GREEN}âœ“${NC} $mirror: ${CYAN}${ping_time}ms${NC}       "
        else
            echo -e "${RED}âœ—${NC} $mirror: ${RED}Failed${NC}       "
        fi
    done
    
    # Test International Mirrors
    echo -e "\n${CYAN}${BOLD}Testing International Mirrors...${NC}\n"
    
    for mirror in "${!INTL_MIRRORS[@]}"; do
        echo -ne "${GRAY}Testing $mirror...${NC}\r"
        
        ping_time=$(ping -c 2 -W 2 $mirror 2>/dev/null | grep rtt | awk -F'/' '{print $5}' | cut -d. -f1)
        
        if [ -n "$ping_time" ] && [ "$ping_time" -gt 0 ]; then
            intl_times["$mirror"]="$ping_time"
            echo -e "${GREEN}âœ“${NC} $mirror: ${CYAN}${ping_time}ms${NC}       "
        else
            echo -e "${RED}âœ—${NC} $mirror: ${RED}Failed${NC}       "
        fi
    done
    
    # Find fastest Iranian mirror
    BEST_IRAN=""
    BEST_IRAN_TIME=999999
    
    for mirror in "${!iran_times[@]}"; do
        time="${iran_times[$mirror]}"
        if [ "$time" -lt "$BEST_IRAN_TIME" ]; then
            BEST_IRAN_TIME=$time
            BEST_IRAN=$mirror
        fi
    done
    
    # Find fastest International mirror
    BEST_INTL=""
    BEST_INTL_TIME=999999
    
    for mirror in "${!intl_times[@]}"; do
        time="${intl_times[$mirror]}"
        if [ "$time" -lt "$BEST_INTL_TIME" ]; then
            BEST_INTL_TIME=$time
            BEST_INTL=$mirror
        fi
    done
    
    # Display results
    echo ""
    echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${CYAN}${BOLD}                    RESULTS                                ${NC}"
    echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    if [ -n "$BEST_IRAN" ]; then
        echo -e "${GREEN}${BOLD}ðŸ‡®ðŸ‡· Fastest Iranian Mirror:${NC}"
        echo -e "   ${CYAN}$BEST_IRAN${NC} - ${GREEN}${BEST_IRAN_TIME}ms${NC}\n"
    else
        echo -e "${RED}${BOLD}ðŸ‡®ðŸ‡· Iranian Mirror:${NC} ${RED}No mirror responded${NC}\n"
    fi
    
    if [ -n "$BEST_INTL" ]; then
        echo -e "${GREEN}${BOLD}ðŸŒ Fastest International Mirror:${NC}"
        echo -e "   ${CYAN}$BEST_INTL${NC} - ${GREEN}${BEST_INTL_TIME}ms${NC}\n"
    else
        echo -e "${RED}${BOLD}ðŸŒ International Mirror:${NC} ${RED}No mirror responded${NC}\n"
    fi
    
    echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    # Check if we have at least one mirror
    if [ -z "$BEST_IRAN" ] && [ -z "$BEST_INTL" ]; then
        print_status "FAIL" "No mirrors responded"
        press_enter
        return
    fi
    
    # Let user choose
    echo -e "${YELLOW}Which mirror do you want to use?${NC}\n"
    
    local choice_num=1
    
    if [ -n "$BEST_IRAN" ]; then
        echo -e "  ${choice_num}) ðŸ‡®ðŸ‡· Iranian: ${CYAN}$BEST_IRAN${NC} (${GREEN}${BEST_IRAN_TIME}ms${NC}) ${GREEN}${BOLD}[RECOMMENDED]${NC}"
        IRAN_CHOICE=$choice_num
        choice_num=$((choice_num + 1))
    fi
    
    if [ -n "$BEST_INTL" ]; then
        echo -e "  ${choice_num}) ðŸŒ International: ${CYAN}$BEST_INTL${NC} (${GREEN}${BEST_INTL_TIME}ms${NC})"
        INTL_CHOICE=$choice_num
        choice_num=$((choice_num + 1))
    fi
    
    echo -e "  0) Cancel\n"
    
    echo -ne "${YELLOW}Your choice: ${NC}"
    read mirror_choice
    
    SELECTED_MIRROR=""
    SELECTED_PATH=""
    
    if [ -n "$BEST_IRAN" ] && [ "$mirror_choice" = "$IRAN_CHOICE" ]; then
        SELECTED_MIRROR=$BEST_IRAN
        SELECTED_PATH="${IRAN_MIRRORS[$BEST_IRAN]}"
        echo -e "\n${GREEN}âœ“${NC} Selected: ${CYAN}$BEST_IRAN${NC} (Iranian)\n"
    elif [ -n "$BEST_INTL" ] && [ "$mirror_choice" = "$INTL_CHOICE" ]; then
        SELECTED_MIRROR=$BEST_INTL
        SELECTED_PATH="${INTL_MIRRORS[$BEST_INTL]}"
        echo -e "\n${GREEN}âœ“${NC} Selected: ${CYAN}$BEST_INTL${NC} (International)\n"
    elif [ "$mirror_choice" = "0" ]; then
        print_status "INFO" "Operation cancelled"
        press_enter
        return
    else
        print_status "FAIL" "Invalid choice"
        press_enter
        return
    fi
    
    # Apply mirror
    echo -e "${CYAN}Applying mirror configuration...${NC}\n"
    
    # Update ubuntu.sources (Ubuntu 24.04+)
    if [ -f /etc/apt/sources.list.d/ubuntu.sources ]; then
        sed -i "s|^URIs:.*|URIs: http://$SELECTED_PATH|" /etc/apt/sources.list.d/ubuntu.sources
        sed -i "s|^# URIs:.*|URIs: http://$SELECTED_PATH|" /etc/apt/sources.list.d/ubuntu.sources
        print_status "OK" "Updated ubuntu.sources"
    fi
    
    # Update sources.list (older Ubuntu/Debian)
    if [ -f /etc/apt/sources.list ] && [ -s /etc/apt/sources.list ]; then
        # Replace all Ubuntu mirror URLs
        sed -i "s|http://[a-zA-Z0-9./-]*archive\.ubuntu\.com/ubuntu|http://$SELECTED_PATH|g" /etc/apt/sources.list
        sed -i "s|http://[a-zA-Z0-9./-]*security\.ubuntu\.com/ubuntu|http://$SELECTED_PATH|g" /etc/apt/sources.list
        sed -i "s|http://[a-zA-Z0-9./-]*\(ubuntu\|debian\)[a-zA-Z0-9./-]*/ubuntu|http://$SELECTED_PATH|g" /etc/apt/sources.list
        print_status "OK" "Updated sources.list"
    fi
    
    # Clean and update
    rm -rf /var/lib/apt/lists/* 2>/dev/null
    print_status "INFO" "Updating package lists..."
    echo ""
    
    if apt-get update 2>&1 | tee /tmp/apt-update.log | grep -q "^Hit\|^Get"; then
        if ! grep -qi "error\|failed\|404" /tmp/apt-update.log; then
            print_status "OK" "Mirror updated and tested successfully!"
            echo ""
            echo -e "${GREEN}${BOLD}âœ“ Your system is now using: ${CYAN}http://$SELECTED_PATH${NC}"
        else
            print_status "FAIL" "Mirror verification failed"
            echo -e "${YELLOW}Restoring backup...${NC}"
            
            # Restore backups
            [ -f /etc/apt/sources.list.bak ] && cp /etc/apt/sources.list.bak /etc/apt/sources.list
            [ -f /etc/apt/sources.list.d/ubuntu.sources.bak ] && cp /etc/apt/sources.list.d/ubuntu.sources.bak /etc/apt/sources.list.d/ubuntu.sources
            
            rm -rf /var/lib/apt/lists/* 2>/dev/null
            apt-get update -qq > /dev/null 2>&1
            print_status "OK" "Backup restored"
        fi
    else
        print_status "FAIL" "Failed to update package lists"
        echo -e "${YELLOW}Restoring backup...${NC}"
        
        # Restore backups
        [ -f /etc/apt/sources.list.bak ] && cp /etc/apt/sources.list.bak /etc/apt/sources.list
        [ -f /etc/apt/sources.list.d/ubuntu.sources.bak ] && cp /etc/apt/sources.list.d/ubuntu.sources.bak /etc/apt/sources.list.d/ubuntu.sources
        
        rm -rf /var/lib/apt/lists/* 2>/dev/null
        apt-get update -qq > /dev/null 2>&1
        print_status "OK" "Backup restored"
    fi
    
    rm -f /tmp/apt-update.log 2>/dev/null
    
    press_enter
}

#==============================================================================
# System Benchmark
#==============================================================================

run_benchmark() {
    print_header "SYSTEM BENCHMARK"
    
    echo -e "${YELLOW}Running comprehensive benchmark...${NC}\n"
    echo -e "${CYAN}This may take a few minutes${NC}\n"
    
    # Run bench.sh
    curl -Lso- bench.sh 2>/dev/null | bash
    
    press_enter
}

#==============================================================================
# Main Menu
#==============================================================================

main_menu() {
    while true; do
        print_banner
        show_system_info
        
        echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
        echo -e "${CYAN}${BOLD}                        MAIN MENU                          ${NC}"
        echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
        
        echo -e "${WHITE} 1)${NC} ðŸŒ Network & Server Optimization"
        echo -e "${WHITE} 2)${NC} ðŸ” Check IP Reputation & Security"
        echo -e "${WHITE} 3)${NC} ðŸ”„ Optimize Repository Mirrors"
        echo -e "${WHITE} 4)${NC} ðŸ“Š Server Monitoring ${GREEN}${BOLD}[LIVE]${NC}"
        echo -e "${WHITE} 5)${NC} ðŸ“Š System Benchmark"
        echo -e "${WHITE} 6)${NC} ðŸ”§ Service & Log Management ${CYAN}${BOLD}[NEW]${NC}"
        echo -e "${WHITE} 0)${NC} âŒ Exit"
        
        echo -e "\n${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
        
        echo -ne "${YELLOW}Select option: ${NC}"
        read choice
        
        case $choice in
            1) network_optimization_menu ;;
            2) check_ip_reputation ;;
            3) optimize_mirrors ;;
            4) monitoring ;;
            5) run_benchmark ;;
            6) service_log_menu ;;
            0)
                echo -e "\n${GREEN}Thank you for using Server Management Tool!${NC}\n"
                exit 0
                ;;
            *)
                print_status "FAIL" "Invalid option"
                sleep 1
                ;;
        esac
    done
}

#==============================================================================
# Main Execution
#==============================================================================

# Check root
check_root

# Detect OS
detect_os

# Start
main_menu
