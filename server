#!/usr/bin/env bash

#==============================================================================
# Server Management & Optimization Tool
# Version: 2.0.0
# Focus: Network Optimization, Performance, and Server Management
#==============================================================================

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
BOLD='\033[1m'
NC='\033[0m'

# Configuration
SCRIPT_VERSION="2.0.0"
SYSCTL_CONF="/etc/sysctl.conf"
BACKUP_DIR="/root/server-tool-backups"

# Create backup directory
mkdir -p "$BACKUP_DIR"

#==============================================================================
# Utility Functions
#==============================================================================

print_banner() {
    clear
    echo -e "${CYAN}${BOLD}"
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                               â•‘
â•‘         SERVER MANAGEMENT & OPTIMIZATION TOOL                 â•‘
â•‘                     Version 2.0.0                             â•‘
â•‘                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    echo -e "${NC}"
}

print_header() {
    echo -e "\n${BLUE}${BOLD}â•”$(printf 'â•%.0s' {1..63})â•—${NC}"
    printf "${BLUE}${BOLD}â•‘${NC} %-61s ${BLUE}${BOLD}â•‘${NC}\n" "$1"
    echo -e "${BLUE}${BOLD}â•š$(printf 'â•%.0s' {1..63})â•${NC}\n"
}

print_status() {
    local status="$1"
    local message="$2"
    case $status in
        "OK") echo -e "${GREEN}âœ“${NC} $message" ;;
        "WARN") echo -e "${YELLOW}âš ${NC} $message" ;;
        "FAIL") echo -e "${RED}âœ—${NC} $message" ;;
        "INFO") echo -e "${CYAN}â„¹${NC} $message" ;;
    esac
}

check_root() {
    if [ "$(id -u)" != "0" ]; then
        echo -e "${RED}This script must be run as root or with sudo${NC}"
        exit 1
    fi
}

detect_os() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS=$ID
        OS_VERSION=$VERSION_ID
    else
        OS=$(uname -s)
        OS_VERSION=$(uname -r)
    fi
}

backup_file() {
    local file="$1"
    if [ -f "$file" ]; then
        cp "$file" "$BACKUP_DIR/$(basename $file).backup.$(date +%Y%m%d-%H%M%S)"
        print_status "INFO" "Backup created: $file"
    fi
}

press_enter() {
    echo ""
    read -p "$(echo -e ${CYAN}Press Enter to continue...${NC})"
}

#==============================================================================
# System Information
#==============================================================================

show_system_info() {
    print_header "SYSTEM INFORMATION"
    
    # Get info
    HOSTNAME=$(hostname)
    KERNEL=$(uname -r)
    CPU_MODEL=$(lscpu | grep "Model name" | cut -d':' -f2 | xargs)
    CPU_CORES=$(nproc)
    TOTAL_MEM=$(free -h | awk '/^Mem:/ {print $2}')
    USED_MEM=$(free -h | awk '/^Mem:/ {print $3}')
    TOTAL_DISK=$(df -h / | awk 'NR==2 {print $2}')
    USED_DISK=$(df -h / | awk 'NR==2 {print $3}')
    UPTIME=$(uptime -p 2>/dev/null || uptime)
    PUBLIC_IP=$(curl -s --max-time 3 https://api.ipify.org 2>/dev/null || echo "N/A")
    
    # Display
    echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Hostname" "$HOSTNAME"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Kernel" "$KERNEL"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "CPU" "${CPU_MODEL:0:34}"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "CPU Cores" "$CPU_CORES"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Memory" "$USED_MEM / $TOTAL_MEM"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Disk" "$USED_DISK / $TOTAL_DISK"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Uptime" "${UPTIME:0:34}"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: ${YELLOW}%-34s${NC} ${CYAN}â•‘${NC}\n" "Public IP" "$PUBLIC_IP"
    echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
}

#==============================================================================
# TCP Congestion Control - BBR
#==============================================================================

install_bbr() {
    print_header "INSTALL BBR (TCP Congestion Control)"
    
    echo -e "${YELLOW}BBR improves network throughput and reduces latency${NC}\n"
    
    # Check current
    current_cc=$(sysctl net.ipv4.tcp_congestion_control 2>/dev/null | awk '{print $3}')
    echo -e "Current congestion control: ${CYAN}$current_cc${NC}\n"
    
    if [ "$current_cc" = "bbr" ]; then
        print_status "OK" "BBR is already installed and active"
        press_enter
        return
    fi
    
    # Check kernel version
    kernel_version=$(uname -r | cut -d. -f1-2)
    major=$(echo $kernel_version | cut -d. -f1)
    minor=$(echo $kernel_version | cut -d. -f2)
    
    if [ "$major" -lt 4 ] || ([ "$major" -eq 4 ] && [ "$minor" -lt 9 ]); then
        print_status "FAIL" "BBR requires kernel 4.9+. Current: $(uname -r)"
        echo -e "${YELLOW}Please upgrade your kernel first${NC}"
        press_enter
        return
    fi
    
    print_status "OK" "Kernel version compatible: $(uname -r)"
    
    # Backup sysctl.conf
    backup_file "$SYSCTL_CONF"
    
    # Remove old BBR settings
    sed -i '/net.core.default_qdisc/d' "$SYSCTL_CONF"
    sed -i '/net.ipv4.tcp_congestion_control/d' "$SYSCTL_CONF"
    
    # Add BBR settings
    echo "" >> "$SYSCTL_CONF"
    echo "# BBR Congestion Control" >> "$SYSCTL_CONF"
    echo "net.core.default_qdisc=fq" >> "$SYSCTL_CONF"
    echo "net.ipv4.tcp_congestion_control=bbr" >> "$SYSCTL_CONF"
    
    # Apply settings
    sysctl -p > /dev/null 2>&1
    
    # Verify
    if sysctl net.ipv4.tcp_congestion_control | grep -q "bbr"; then
        print_status "OK" "BBR installed and activated successfully!"
        echo ""
        print_status "INFO" "BBR will persist after reboot"
    else
        print_status "FAIL" "Failed to activate BBR"
    fi
    
    press_enter
}

#==============================================================================
# TCP Congestion Control - Hybla
#==============================================================================

install_hybla() {
    print_header "INSTALL HYBLA (TCP Congestion Control)"
    
    echo -e "${YELLOW}Hybla is optimized for high-latency networks (satellite, long-distance)${NC}\n"
    
    # Check current
    current_cc=$(sysctl net.ipv4.tcp_congestion_control 2>/dev/null | awk '{print $3}')
    echo -e "Current congestion control: ${CYAN}$current_cc${NC}\n"
    
    if [ "$current_cc" = "hybla" ]; then
        print_status "OK" "Hybla is already installed and active"
        press_enter
        return
    fi
    
    # Load hybla module
    modprobe tcp_hybla 2>/dev/null
    
    if ! lsmod | grep -q tcp_hybla; then
        print_status "FAIL" "Cannot load tcp_hybla module"
        echo -e "${YELLOW}Your kernel may not support Hybla${NC}"
        press_enter
        return
    fi
    
    print_status "OK" "Hybla module loaded"
    
    # Make module load on boot
    if ! grep -q "tcp_hybla" /etc/modules 2>/dev/null; then
        echo "tcp_hybla" >> /etc/modules
    fi
    
    # Backup sysctl.conf
    backup_file "$SYSCTL_CONF"
    
    # Remove old settings
    sed -i '/net.core.default_qdisc/d' "$SYSCTL_CONF"
    sed -i '/net.ipv4.tcp_congestion_control/d' "$SYSCTL_CONF"
    
    # Add Hybla settings
    echo "" >> "$SYSCTL_CONF"
    echo "# Hybla Congestion Control" >> "$SYSCTL_CONF"
    echo "net.core.default_qdisc=fq" >> "$SYSCTL_CONF"
    echo "net.ipv4.tcp_congestion_control=hybla" >> "$SYSCTL_CONF"
    
    # Apply settings
    sysctl -p > /dev/null 2>&1
    
    # Verify
    if sysctl net.ipv4.tcp_congestion_control | grep -q "hybla"; then
        print_status "OK" "Hybla installed and activated successfully!"
        echo ""
        print_status "INFO" "Hybla will persist after reboot"
    else
        print_status "FAIL" "Failed to activate Hybla"
    fi
    
    press_enter
}

#==============================================================================
# Remove TCP Optimization
#==============================================================================

remove_tcp_optimization() {
    print_header "REMOVE TCP OPTIMIZATION"
    
    echo -e "${YELLOW}This will remove BBR/Hybla and restore default settings${NC}\n"
    
    read -p "$(echo -e ${RED}Are you sure? [y/N]:${NC} )" confirm
    if [[ ! $confirm =~ ^[Yy]$ ]]; then
        return
    fi
    
    # Backup sysctl.conf
    backup_file "$SYSCTL_CONF"
    
    # Remove settings
    sed -i '/# BBR Congestion Control/d' "$SYSCTL_CONF"
    sed -i '/# Hybla Congestion Control/d' "$SYSCTL_CONF"
    sed -i '/net.core.default_qdisc/d' "$SYSCTL_CONF"
    sed -i '/net.ipv4.tcp_congestion_control/d' "$SYSCTL_CONF"
    
    # Set to default (cubic)
    sysctl -w net.ipv4.tcp_congestion_control=cubic > /dev/null 2>&1
    
    # Remove hybla from modules
    sed -i '/tcp_hybla/d' /etc/modules 2>/dev/null
    
    print_status "OK" "TCP optimization removed"
    print_status "INFO" "Default congestion control (cubic) restored"
    
    press_enter
}

#==============================================================================
# MTU Finder & Optimizer
#==============================================================================

mtu_finder() {
    print_header "MTU FINDER & OPTIMIZER"
    
    # Get primary interface
    PRIMARY_IFACE=$(ip route | grep default | awk '{print $5}' | head -1)
    
    if [ -z "$PRIMARY_IFACE" ]; then
        print_status "FAIL" "Cannot detect primary network interface"
        press_enter
        return
    fi
    
    current_mtu=$(ip link show "$PRIMARY_IFACE" 2>/dev/null | grep -oP 'mtu \K\d+' || echo "1500")
    echo -e "Interface: ${CYAN}$PRIMARY_IFACE${NC}"
    echo -e "Current MTU: ${CYAN}$current_mtu${NC}\n"
    
    echo -e "${CYAN}Select test destination:${NC}"
    echo "  1) Google DNS (8.8.8.8)"
    echo "  2) Cloudflare DNS (1.1.1.1)"
    echo "  3) Custom IP"
    echo "  0) Back"
    echo ""
    read -p "Choice: " dest_choice
    
    case $dest_choice in
        1) test_ip="8.8.8.8" ;;
        2) test_ip="1.1.1.1" ;;
        3) read -p "Enter IP address: " test_ip ;;
        0) return ;;
        *) print_status "FAIL" "Invalid choice"; press_enter; return ;;
    esac
    
    # Test connectivity
    if ! ping -c 1 -W 2 "$test_ip" &>/dev/null; then
        print_status "FAIL" "Cannot reach $test_ip"
        press_enter
        return
    fi
    
    print_status "OK" "Testing connectivity to $test_ip"
    
    echo ""
    echo -e "${CYAN}Finding optimal MTU...${NC}\n"
    
    # Binary search for optimal MTU
    local min_mtu=1000
    local max_mtu=1500
    local optimal_mtu=$min_mtu
    local step=10
    
    for ((mtu=$min_mtu; mtu<=$max_mtu; mtu+=$step)); do
        local payload=$((mtu - 28))
        echo -ne "${GRAY}Testing MTU $mtu...${NC}\r"
        
        if ping -M do -c 1 -s $payload -W 1 "$test_ip" &>/dev/null; then
            optimal_mtu=$mtu
            echo -e "${GREEN}âœ“${NC} MTU $mtu: ${GREEN}OK${NC}     "
        else
            echo -e "${RED}âœ—${NC} MTU $mtu: ${RED}Failed${NC}"
            break
        fi
    done
    
    # Recommend MTU
    local recommended_mtu=$((optimal_mtu - 2))
    
    echo ""
    print_status "OK" "Optimal MTU found: $optimal_mtu"
    print_status "INFO" "Recommended MTU: $recommended_mtu"
    
    echo ""
    read -p "$(echo -e ${YELLOW}Apply MTU $recommended_mtu? [y/N]:${NC} )" apply_mtu
    
    if [[ $apply_mtu =~ ^[Yy]$ ]]; then
        # Set MTU temporarily
        ip link set dev "$PRIMARY_IFACE" mtu "$recommended_mtu" 2>/dev/null
        print_status "OK" "MTU temporarily set to $recommended_mtu"
        
        # Make permanent
        if [ -f "/etc/network/interfaces" ]; then
            backup_file "/etc/network/interfaces"
            if ! grep -q "mtu $recommended_mtu" /etc/network/interfaces; then
                sed -i "/iface $PRIMARY_IFACE/a \    mtu $recommended_mtu" /etc/network/interfaces 2>/dev/null
                print_status "OK" "MTU saved to /etc/network/interfaces"
            fi
        elif [ -f "/etc/sysconfig/network-scripts/ifcfg-$PRIMARY_IFACE" ]; then
            local ifcfg="/etc/sysconfig/network-scripts/ifcfg-$PRIMARY_IFACE"
            backup_file "$ifcfg"
            if grep -q "MTU=" "$ifcfg"; then
                sed -i "s/MTU=.*/MTU=$recommended_mtu/" "$ifcfg"
            else
                echo "MTU=$recommended_mtu" >> "$ifcfg"
            fi
            print_status "OK" "MTU saved to $ifcfg"
        else
            print_status "WARN" "Manual configuration may be needed for persistence"
        fi
        
        print_status "INFO" "MTU will persist after reboot"
    fi
    
    press_enter
}

#==============================================================================
# DNS Optimizer
#==============================================================================

optimize_dns() {
    print_header "DNS OPTIMIZER"
    
    echo -e "${YELLOW}Testing DNS servers to find the fastest...${NC}\n"
    
    # DNS servers to test
    declare -A dns_servers=(
        ["Google"]="8.8.8.8"
        ["Cloudflare"]="1.1.1.1"
        ["Quad9"]="9.9.9.9"
        ["OpenDNS"]="208.67.222.222"
        ["Shecan"]="178.22.122.100"
        ["403"]="10.202.10.202"
        ["Radar"]="10.202.10.10"
        ["Electro"]="78.157.42.100"
    )
    
    declare -A dns_times
    local total_dns=${#dns_servers[@]}
    local current=0
    
    # Progress bar function
    show_progress() {
        local current=$1
        local total=$2
        local name=$3
        local status=$4
        
        local percent=$((current * 100 / total))
        local filled=$((current * 40 / total))
        local empty=$((40 - filled))
        
        echo -ne "\r${CYAN}Progress: ["
        printf "${GREEN}â–ˆ%.0s" $(seq 1 $filled)
        printf "${GRAY}â–‘%.0s" $(seq 1 $empty)
        echo -ne "${CYAN}] ${percent}%${NC} - ${status}"
    }
    
    echo -e "${CYAN}Testing $total_dns DNS servers...${NC}\n"
    
    # Test each DNS
    for name in "${!dns_servers[@]}"; do
        current=$((current + 1))
        ip="${dns_servers[$name]}"
        
        show_progress $current $total_dns "$name" "Testing $name ($ip)..."
        
        # Test with timeout using dig
        if command -v dig &>/dev/null; then
            # Use timeout command if available
            if command -v timeout &>/dev/null; then
                response_time=$(timeout 3 dig @$ip google.com +time=2 +tries=1 2>/dev/null | grep "Query time:" | awk '{print $4}')
            else
                response_time=$(dig @$ip google.com +time=2 +tries=1 2>/dev/null | grep "Query time:" | awk '{print $4}')
            fi
            
            if [ -n "$response_time" ] && [ "$response_time" -gt 0 ] 2>/dev/null; then
                dns_times["$name"]="$response_time"
            fi
        else
            # Fallback to ping with timeout
            ping_time=$(ping -c 2 -W 2 $ip 2>/dev/null | tail -1 | awk -F'/' '{print $5}' | cut -d'.' -f1)
            if [ -n "$ping_time" ] && [ "$ping_time" -gt 0 ] 2>/dev/null; then
                dns_times["$name"]="$ping_time"
            fi
        fi
        
        sleep 0.1
    done
    
    # Clear progress line
    echo -ne "\r$(printf ' %.0s' {1..80})\r"
    
    echo -e "\n${CYAN}${BOLD}Test Results:${NC}\n"
    
    # Display results
    for name in "${!dns_servers[@]}"; do
        ip="${dns_servers[$name]}"
        if [ -n "${dns_times[$name]}" ]; then
            time="${dns_times[$name]}"
            echo -e "${GREEN}âœ“${NC} ${BOLD}$name${NC} ($ip): ${CYAN}${time}ms${NC}"
        else
            echo -e "${RED}âœ—${NC} ${BOLD}$name${NC} ($ip): ${RED}Timeout/Failed${NC}"
        fi
    done
    
    # Find fastest
    fastest_dns=""
    fastest_time=999999
    
    for name in "${!dns_times[@]}"; do
        time="${dns_times[$name]}"
        if [ "$time" -lt "$fastest_time" ]; then
            fastest_time=$time
            fastest_dns=$name
        fi
    done
    
    if [ -z "$fastest_dns" ]; then
        echo ""
        print_status "FAIL" "No DNS servers responded"
        press_enter
        return
    fi
    
    fastest_ip="${dns_servers[$fastest_dns]}"
    
    echo ""
    echo -e "${GREEN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${GREEN}ğŸ† FASTEST DNS: ${YELLOW}${BOLD}$fastest_dns${NC} ${GREEN}($fastest_ip)${NC} - ${CYAN}${BOLD}${fastest_time}ms${NC}"
    echo -e "${GREEN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    
    echo ""
    read -p "$(echo -e ${YELLOW}Apply this DNS? [y/N]:${NC} )" apply_dns
    
    if [[ $apply_dns =~ ^[Yy]$ ]]; then
        # Backup resolv.conf
        backup_file "/etc/resolv.conf"
        
        # Remove immutable flag if set
        chattr -i /etc/resolv.conf 2>/dev/null || true
        
        # Set DNS
        cat > /etc/resolv.conf << EOF
# DNS Configuration - Set by Server Tool
# Fastest: $fastest_dns ($fastest_ip) - ${fastest_time}ms
nameserver $fastest_ip
nameserver 8.8.8.8
nameserver 1.1.1.1
EOF
        
        # Make immutable (prevent changes)
        chattr +i /etc/resolv.conf 2>/dev/null || true
        
        print_status "OK" "DNS set to $fastest_dns ($fastest_ip)"
        print_status "INFO" "Configuration saved and protected"
        print_status "INFO" "DNS will persist after reboot"
        
        # Test new DNS
        echo ""
        echo -e "${CYAN}Testing new DNS configuration...${NC}"
        if nslookup google.com &>/dev/null; then
            print_status "OK" "DNS is working correctly"
        else
            print_status "WARN" "DNS test failed, but configuration saved"
        fi
    fi
    
    press_enter
}


manage_ping() {
    print_header "BLOCK/UNBLOCK SERVER PING"
    
    # Check current status
    current_setting=$(sysctl net.ipv4.icmp_echo_ignore_all 2>/dev/null | awk '{print $3}')
    
    if [ "$current_setting" = "1" ]; then
        echo -e "Current status: ${RED}Ping is BLOCKED${NC}\n"
    else
        echo -e "Current status: ${GREEN}Ping is ALLOWED${NC}\n"
    fi
    
    echo "  1) Block Ping"
    echo "  2) Unblock Ping"
    echo "  0) Back"
    echo ""
    read -p "Choice: " ping_choice
    
    case $ping_choice in
        1)
            # Block ping
            backup_file "$SYSCTL_CONF"
            sed -i '/net.ipv4.icmp_echo_ignore_all/d' "$SYSCTL_CONF"
            echo "net.ipv4.icmp_echo_ignore_all=1" >> "$SYSCTL_CONF"
            sysctl -w net.ipv4.icmp_echo_ignore_all=1 > /dev/null 2>&1
            print_status "OK" "Ping blocked successfully"
            print_status "INFO" "Setting will persist after reboot"
            ;;
        2)
            # Unblock ping
            backup_file "$SYSCTL_CONF"
            sed -i '/net.ipv4.icmp_echo_ignore_all/d' "$SYSCTL_CONF"
            echo "net.ipv4.icmp_echo_ignore_all=0" >> "$SYSCTL_CONF"
            sysctl -w net.ipv4.icmp_echo_ignore_all=0 > /dev/null 2>&1
            print_status "OK" "Ping unblocked successfully"
            print_status "INFO" "Setting will persist after reboot"
            ;;
        0)
            return
            ;;
        *)
            print_status "FAIL" "Invalid choice"
            ;;
    esac
    
    press_enter
}

#==============================================================================
# Complete Server Optimization
#==============================================================================

optimize_server() {
    print_header "COMPLETE SERVER OPTIMIZATION"
    
    echo -e "${YELLOW}This will apply comprehensive system optimizations${NC}"
    echo -e "${YELLOW}Including: Memory, Network, File System, and Security${NC}\n"
    
    echo -e "${RED}âš  WARNING: This will modify system configuration files${NC}\n"
    
    read -p "$(echo -e ${YELLOW}Continue? [y/N]:${NC} )" confirm
    if [[ ! $confirm =~ ^[Yy]$ ]]; then
        return
    fi
    
    echo ""
    print_status "INFO" "Backing up configuration files..."
    
    # Backup files
    backup_file "$SYSCTL_CONF"
    backup_file "/etc/security/limits.conf"
    
    # Create new sysctl.conf
    cat > "$SYSCTL_CONF" << 'EOF'
# Server Optimization Configuration
# Generated by Server Management Tool

# Memory Management
vm.swappiness=10
vm.dirty_ratio=20
vm.dirty_background_ratio=10

# File System
fs.file-max=2097152

# Network Core
net.core.somaxconn=4096
net.core.netdev_max_backlog=16384

# IPv4 Network
net.ipv4.ip_local_port_range=1024 65535
net.ipv4.ip_nonlocal_bind=1

# TCP Configuration
net.ipv4.tcp_fin_timeout=15
net.ipv4.tcp_keepalive_time=300
net.ipv4.tcp_syncookies=0
net.ipv4.tcp_max_orphans=262144
net.ipv4.tcp_max_syn_backlog=8192
net.ipv4.tcp_max_tw_buckets=262144
net.ipv4.tcp_reordering=3

# TCP Memory
net.ipv4.tcp_mem=786432 1697152 1945728
net.ipv4.tcp_rmem=4096 87380 16777216
net.ipv4.tcp_wmem=4096 65536 16777216

# TCP Retries
net.ipv4.tcp_syn_retries=5

# TCP Reuse
net.ipv4.tcp_tw_reuse=1
EOF
    
    print_status "OK" "Created new sysctl.conf"
    
    # Create new limits.conf
    cat > /etc/security/limits.conf << 'EOF'
# System Limits Configuration
# Generated by Server Management Tool

* soft nproc 65535
* hard nproc 65535
* soft nofile 1048576
* hard nofile 1048576

root soft nproc 65535
root hard nproc 65535
root soft nofile 1048576
root hard nofile 1048576
EOF
    
    print_status "OK" "Created new limits.conf"
    
    # Apply sysctl settings
    print_status "INFO" "Applying kernel parameters..."
    sysctl -p > /dev/null 2>&1
    
    print_status "OK" "System optimization completed!"
    
    echo ""
    echo -e "${CYAN}Applied optimizations:${NC}"
    echo -e "  ${GREEN}âœ“${NC} Memory management (swappiness, dirty ratio)"
    echo -e "  ${GREEN}âœ“${NC} File system limits (file-max)"
    echo -e "  ${GREEN}âœ“${NC} Network buffers and backlog"
    echo -e "  ${GREEN}âœ“${NC} TCP parameters (timeouts, memory)"
    echo -e "  ${GREEN}âœ“${NC} Process and file descriptor limits"
    
    echo ""
    print_status "INFO" "All settings will persist after reboot"
    print_status "INFO" "Backups saved in: $BACKUP_DIR"
    
    press_enter
}

#==============================================================================
# IP Reputation & Security Check
#==============================================================================

check_ip_reputation() {
    print_header "IP REPUTATION & SECURITY CHECK"
    
    # Get public IP
    echo -ne "${CYAN}Getting your public IP...${NC}\r"
    PUBLIC_IP=$(curl -s --max-time 5 https://api.ipify.org 2>/dev/null || echo "N/A")
    
    if [ "$PUBLIC_IP" = "N/A" ]; then
        print_status "FAIL" "Cannot get public IP address"
        press_enter
        return
    fi
    
    echo -e "${GREEN}âœ“${NC} Your Public IP: ${YELLOW}${BOLD}$PUBLIC_IP${NC}               \n"
    
    local total_checks=0
    local passed_checks=0
    local critical_issues=0
    
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"
    
    # 1. IP-API - Basic Info
    echo -e "${BOLD}[1/8] IP Geolocation & ISP${NC}"
    echo -ne "${GRAY}Checking...${NC}\r"
    
    ip_info=$(curl -s --max-time 5 "http://ip-api.com/json/$PUBLIC_IP?fields=status,country,city,isp,org,proxy,hosting" 2>/dev/null)
    
    if [ -n "$ip_info" ] && echo "$ip_info" | grep -q "success"; then
        country=$(echo "$ip_info" | grep -o '"country":"[^"]*' | cut -d'"' -f4)
        city=$(echo "$ip_info" | grep -o '"city":"[^"]*' | cut -d'"' -f4)
        isp=$(echo "$ip_info" | grep -o '"isp":"[^"]*' | cut -d'"' -f4)
        is_proxy=$(echo "$ip_info" | grep -o '"proxy":true' | wc -l)
        is_hosting=$(echo "$ip_info" | grep -o '"hosting":true' | wc -l)
        
        echo -e "${GREEN}âœ“${NC} Location: ${CYAN}$city, $country${NC}                    "
        echo -e "${GREEN}âœ“${NC} ISP: ${CYAN}${isp:0:50}${NC}"
        
        total_checks=$((total_checks + 1))
        if [ $is_proxy -eq 0 ]; then
            passed_checks=$((passed_checks + 1))
            echo -e "${GREEN}âœ“${NC} Proxy: ${GREEN}Not detected${NC}"
        else
            echo -e "${RED}âœ—${NC} Proxy: ${RED}Detected${NC}"
            critical_issues=$((critical_issues + 1))
        fi
        
        [ $is_hosting -eq 1 ] && echo -e "${YELLOW}âš ${NC} Type: ${YELLOW}Hosting/VPS/Datacenter${NC}" || echo -e "${GREEN}âœ“${NC} Type: ${GREEN}Residential${NC}"
    else
        echo -e "${RED}âœ—${NC} Check failed                        "
    fi
    echo ""
    
    # 2. IPQualityScore
    echo -e "${BOLD}[2/8] IPQualityScore - Fraud Detection${NC}"
    echo -ne "${GRAY}Checking...${NC}\r"
    
    ipqs=$(curl -s --max-time 5 "https://www.ipqualityscore.com/api/json/ip/free/$PUBLIC_IP" 2>/dev/null)
    
    if [ -n "$ipqs" ]; then
        fraud=$(echo "$ipqs" | grep -o '"fraud_score":[0-9]*' | cut -d':' -f2)
        vpn=$(echo "$ipqs" | grep -o '"vpn":true' | wc -l)
        proxy=$(echo "$ipqs" | grep -o '"proxy":true' | wc -l)
        tor=$(echo "$ipqs" | grep -o '"tor":true' | wc -l)
        
        total_checks=$((total_checks + 1))
        
        if [ -n "$fraud" ]; then
            if [ "$fraud" -lt 50 ]; then
                passed_checks=$((passed_checks + 1))
                echo -e "${GREEN}âœ“${NC} Fraud Score: ${GREEN}$fraud/100${NC} (Low)           "
            elif [ "$fraud" -lt 75 ]; then
                echo -e "${YELLOW}âš ${NC} Fraud Score: ${YELLOW}$fraud/100${NC} (Medium)"
            else
                echo -e "${RED}âœ—${NC} Fraud Score: ${RED}$fraud/100${NC} (High)"
                critical_issues=$((critical_issues + 1))
            fi
        fi
        
        [ $vpn -eq 0 ] && echo -e "${GREEN}âœ“${NC} VPN: ${GREEN}Not detected${NC}" || echo -e "${RED}âœ—${NC} VPN: ${RED}Detected${NC}"
        [ $proxy -eq 0 ] && echo -e "${GREEN}âœ“${NC} Proxy: ${GREEN}Not detected${NC}" || echo -e "${RED}âœ—${NC} Proxy: ${RED}Detected${NC}"
        [ $tor -eq 0 ] && echo -e "${GREEN}âœ“${NC} Tor: ${GREEN}Not detected${NC}" || echo -e "${RED}âœ—${NC} Tor: ${RED}Detected${NC}"
    else
        echo -e "${RED}âœ—${NC} Check failed                    "
    fi
    echo ""
    
    # 3. Shodan
    echo -e "${BOLD}[3/8] Shodan - Port Scanner${NC}"
    echo -ne "${GRAY}Checking...${NC}\r"
    
    shodan=$(curl -s --max-time 5 "https://internetdb.shodan.io/$PUBLIC_IP" 2>/dev/null)
    
    if [ -n "$shodan" ] && ! echo "$shodan" | grep -q "No information"; then
        ports=$(echo "$shodan" | grep -o '"ports":\[[^]]*\]' | grep -o '[0-9]*' | tr '\n' ',' | sed 's/,$//')
        vulns=$(echo "$shodan" | grep -o '"vulns":\[[^]]*\]' | grep -o 'CVE-[0-9-]*' | wc -l)
        
        [ -n "$ports" ] && echo -e "${YELLOW}âš ${NC} Ports: ${YELLOW}$ports${NC}        " || echo -e "${GREEN}âœ“${NC} No common ports detected              "
        
        if [ "$vulns" -gt 0 ]; then
            echo -e "${RED}âœ—${NC} Vulnerabilities: ${RED}$vulns CVEs${NC}"
            critical_issues=$((critical_issues + 1))
        else
            echo -e "${GREEN}âœ“${NC} No known vulnerabilities                        "
        fi
    else
        echo -e "${GREEN}âœ“${NC} No data (not heavily scanned)      "
    fi
    echo ""
    
    # 4. DNS Blacklists
    echo -e "${BOLD}[4/8] DNS Blacklists${NC}"
    echo -ne "${GRAY}Checking...${NC}\r"
    
    reversed_ip=$(echo "$PUBLIC_IP" | awk -F. '{print $4"."$3"."$2"."$1}')
    blacklisted=0
    bl_names=""
    
    for rbl in "zen.spamhaus.org" "bl.spamcop.net" "dnsbl.sorbs.net" "b.barracudacentral.org" "bl.spameatingmonkey.net" "dnsbl-1.uceprotect.net"; do
        if host "${reversed_ip}.${rbl}" &>/dev/null; then
            blacklisted=$((blacklisted + 1))
            bl_names="$bl_names$rbl "
        fi
    done
    
    total_checks=$((total_checks + 1))
    
    if [ $blacklisted -eq 0 ]; then
        passed_checks=$((passed_checks + 1))
        echo -e "${GREEN}âœ“${NC} Clean (0/6 lists)${NC}            "
    else
        echo -e "${RED}âœ—${NC} Listed in $blacklisted/6 lists${NC}"
        echo -e "   ${RED}$bl_names${NC}"
        critical_issues=$((critical_issues + 1))
    fi
    echo ""
    
    # 5. IPHub
    echo -e "${BOLD}[5/8] IPHub - Proxy Detection${NC}"
    echo -ne "${GRAY}Checking...${NC}\r"
    
    iphub=$(curl -s --max-time 5 "http://v2.api.iphub.info/ip/$PUBLIC_IP" 2>/dev/null)
    
    if [ -n "$iphub" ]; then
        block=$(echo "$iphub" | grep -o '"block":[0-2]' | cut -d':' -f2)
        total_checks=$((total_checks + 1))
        
        case "$block" in
            0) passed_checks=$((passed_checks + 1)); echo -e "${GREEN}âœ“${NC} Residential/Business IP                  " ;;
            1) echo -e "${RED}âœ—${NC} Proxy/VPN detected${NC}"; critical_issues=$((critical_issues + 1)) ;;
            2) echo -e "${YELLOW}âš ${NC} Hosting/Datacenter${NC}" ;;
            *) total_checks=$((total_checks - 1)); echo -e "${YELLOW}âš ${NC} Unknown${NC}" ;;
        esac
    else
        echo -e "${YELLOW}âš ${NC} Check unavailable                         "
    fi
    echo ""
    
    # 6. Scamalytics
    echo -e "${BOLD}[6/8] Scamalytics - Fraud${NC}"
    echo -ne "${GRAY}Checking...${NC}\r"
    
    scam=$(curl -s --max-time 5 "https://scamalytics.com/ip/$PUBLIC_IP" 2>/dev/null)
    
    if [ -n "$scam" ]; then
        fraud_scam=$(echo "$scam" | grep -o 'Fraud Score: [0-9]*' | grep -o '[0-9]*' | head -1)
        total_checks=$((total_checks + 1))
        
        if [ -n "$fraud_scam" ]; then
            if [ "$fraud_scam" -lt 25 ]; then
                passed_checks=$((passed_checks + 1))
                echo -e "${GREEN}âœ“${NC} Score: ${GREEN}$fraud_scam/100${NC} (Very Low)       "
            elif [ "$fraud_scam" -lt 75 ]; then
                echo -e "${YELLOW}âš ${NC} Score: ${YELLOW}$fraud_scam/100${NC}"
            else
                echo -e "${RED}âœ—${NC} Score: ${RED}$fraud_scam/100${NC} (High)"
                critical_issues=$((critical_issues + 1))
            fi
        else
            total_checks=$((total_checks - 1))
            echo -e "${YELLOW}âš ${NC} Could not parse              "
        fi
    else
        echo -e "${YELLOW}âš ${NC} Check failed                         "
    fi
    echo ""
    
    # 7. GetIPIntel
    echo -e "${BOLD}[7/8] GetIPIntel - Proxy Probability${NC}"
    echo -ne "${GRAY}Checking...${NC}\r"
    
    getip=$(curl -s --max-time 5 "http://check.getipintel.net/check.php?ip=$PUBLIC_IP&contact=admin@server.local&flags=b" 2>/dev/null)
    
    if [ -n "$getip" ] && [ "$getip" != "-1" ] && [ "$getip" != "-2" ]; then
        prob=$(echo "$getip" | awk '{printf "%.0f", $1 * 100}')
        total_checks=$((total_checks + 1))
        
        if [ "$prob" -lt 50 ]; then
            passed_checks=$((passed_checks + 1))
            echo -e "${GREEN}âœ“${NC} Probability: ${GREEN}${prob}%${NC} (Low)              "
        elif [ "$prob" -lt 75 ]; then
            echo -e "${YELLOW}âš ${NC} Probability: ${YELLOW}${prob}%${NC}"
        else
            echo -e "${RED}âœ—${NC} Probability: ${RED}${prob}%${NC} (High)"
            critical_issues=$((critical_issues + 1))
        fi
    else
        echo -e "${YELLOW}âš ${NC} Check unavailable                     "
    fi
    echo ""
    
    # 8. AbuseIPDB
    echo -e "${BOLD}[8/8] AbuseIPDB${NC}"
    echo -ne "${GRAY}Checking...${NC}\r"
    
    abuse_page=$(curl -s --max-time 5 "https://www.abuseipdb.com/check/$PUBLIC_IP" 2>/dev/null)
    
    total_checks=$((total_checks + 1))
    if echo "$abuse_page" | grep -qi "whitelisted\|not found\|clean\|0 reports"; then
        passed_checks=$((passed_checks + 1))
        echo -e "${GREEN}âœ“${NC} No abuse reports${NC}              "
    elif echo "$abuse_page" | grep -qi "reported\|blacklist"; then
        echo -e "${RED}âœ—${NC} Abuse reports found${NC}"
        critical_issues=$((critical_issues + 1))
    else
        echo -e "${YELLOW}âš ${NC} Could not verify${NC}"
        total_checks=$((total_checks - 1))
    fi
    echo ""
    
    # Final Score
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"
    
    [ $total_checks -eq 0 ] && total_checks=1
    score=$((passed_checks * 100 / total_checks))
    
    echo -e "${BOLD}FINAL REPUTATION SCORE:${NC}\n"
    
    # Progress bar
    filled=$((score / 2))
    empty=$((50 - filled))
    
    if [ $score -ge 80 ]; then
        color="${GREEN}"
        status="CLEAN IP âœ“"
    elif [ $score -ge 60 ]; then
        color="${YELLOW}"
        status="MODERATE"
    else
        color="${RED}"
        status="DIRTY IP âœ—"
    fi
    
    echo -ne "${color}"
    printf 'â–ˆ%.0s' $(seq 1 $filled)
    echo -ne "${GRAY}"
    printf 'â–‘%.0s' $(seq 1 $empty)
    echo -e "${NC} ${BOLD}${score}%${NC}"
    
    echo ""
    echo -e "${BOLD}Status: ${color}$status${NC}"
    echo -e "Passed: ${GREEN}$passed_checks${NC}/${CYAN}$total_checks${NC}"
    [ $critical_issues -gt 0 ] && echo -e "Critical: ${RED}$critical_issues${NC}"
    
    echo ""
    
    if [ $score -lt 80 ]; then
        echo -e "${YELLOW}${BOLD}RECOMMENDATIONS:${NC}"
        [ $critical_issues -gt 0 ] && echo -e "${RED}âš ${NC} Consider getting a new IP"
        echo -e "${CYAN}Detailed check:${NC}"
        echo -e "â€¢ ${BLUE}https://scamalytics.com/ip/$PUBLIC_IP${NC}"
        echo -e "â€¢ ${BLUE}https://www.abuseipdb.com/check/$PUBLIC_IP${NC}"
    fi
    
    echo ""
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    
    press_enter
}


network_optimization_menu() {
    while true; do
        print_banner
        show_system_info
        
        print_header "NETWORK & SERVER OPTIMIZATION"
        
        echo -e "${WHITE}  1)${NC} Install BBR (TCP Congestion Control)"
        echo -e "${WHITE}  2)${NC} Install Hybla (TCP for High Latency)"
        echo -e "${WHITE}  3)${NC} Remove TCP Optimization (BBR/Hybla)"
        echo -e "${WHITE}  4)${NC} MTU Finder + Auto Set"
        echo -e "${WHITE}  5)${NC} DNS Optimizer (Find & Set Fastest)"
        echo -e "${WHITE}  6)${NC} Block/Unblock Server Ping"
        echo -e "${WHITE}  7)${NC} ${BOLD}Complete Server Optimization${NC} ${CYAN}(Memory, TCP, Limits)${NC}"
        echo -e "${WHITE}  0)${NC} â† Back to Main Menu"
        
        echo ""
        read -p "$(echo -e ${YELLOW}Select option:${NC} )" choice
        
        case $choice in
            1) install_bbr ;;
            2) install_hybla ;;
            3) remove_tcp_optimization ;;
            4) mtu_finder ;;
            5) optimize_dns ;;
            6) manage_ping ;;
            7) optimize_server ;;
            0) break ;;
            *) print_status "FAIL" "Invalid option"; sleep 1 ;;
        esac
    done
}

#==============================================================================
# Repository Mirror Optimizer
#==============================================================================

optimize_mirrors() {
    print_header "OPTIMIZE APT MIRRORS"
    
    if [ "$OS" != "ubuntu" ] && [ "$OS" != "debian" ]; then
        print_status "FAIL" "This feature only works on Ubuntu/Debian"
        press_enter
        return
    fi
    
    echo -e "${YELLOW}Finding fastest mirror for your server...${NC}\n"
    
    # Backup sources
    backup_file "/etc/apt/sources.list"
    [ -f "/etc/apt/sources.list.d/ubuntu.sources" ] && backup_file "/etc/apt/sources.list.d/ubuntu.sources"
    
    # Iran mirrors
    MIRRORS="mirror.iranserver.com ir.ubuntu.sindad.cloud mirror.arvancloud.ir archive.ubuntu.petiak.ir ubuntu.hostiran.ir mirrors.pardisco.co ubuntu.pars.host mirror.0-1.cloud ubuntu.shatel.ir mirror.faraso.org repo.linuxmirrors.ir"
    
    echo -e "${CYAN}Testing Iran mirrors...${NC}\n"
    
    declare -A mirror_times
    
    for mirror in $MIRRORS; do
        echo -ne "${GRAY}Testing $mirror...${NC}\r"
        
        # Ping test
        ping_time=$(ping -c 2 -W 1 $mirror 2>/dev/null | grep rtt | awk -F'/' '{print $5}' | cut -d. -f1)
        
        if [ -n "$ping_time" ] && [ "$ping_time" -gt 0 ]; then
            mirror_times["$mirror"]="$ping_time"
            echo -e "${GREEN}âœ“${NC} $mirror: ${CYAN}${ping_time}ms${NC}          "
        else
            echo -e "${RED}âœ—${NC} $mirror: ${RED}Failed${NC}          "
        fi
    done
    
    # Find fastest
    BEST=""
    BEST_TIME=999999
    
    for mirror in "${!mirror_times[@]}"; do
        time="${mirror_times[$mirror]}"
        if [ "$time" -lt "$BEST_TIME" ]; then
            BEST_TIME=$time
            BEST=$mirror
        fi
    done
    
    if [ -z "$BEST" ]; then
        print_status "FAIL" "No mirror responded"
        press_enter
        return
    fi
    
    echo ""
    print_status "OK" "Fastest mirror: $BEST (${BEST_TIME}ms)"
    
    echo ""
    read -p "$(echo -e ${YELLOW}Apply this mirror? [y/N]:${NC} )" apply_mirror
    
    if [[ $apply_mirror =~ ^[Yy]$ ]]; then
        echo -e "${CYAN}Applying mirror...${NC}"
        
        # Update ubuntu.sources (Ubuntu 24.04+)
        if [ -f /etc/apt/sources.list.d/ubuntu.sources ]; then
            sed -i.bak "s|URIs: .*|URIs: http://$BEST/ubuntu/|" /etc/apt/sources.list.d/ubuntu.sources
            print_status "OK" "Updated ubuntu.sources"
        fi
        
        # Update sources.list (older Ubuntu/Debian)
        if [ -f /etc/apt/sources.list ]; then
            sed -i.bak "s|http://[a-zA-Z0-9.-]*archive.ubuntu.com/ubuntu|http://$BEST/ubuntu|g" /etc/apt/sources.list
            print_status "OK" "Updated sources.list"
        fi
        
        # Clean and update
        rm -rf /var/lib/apt/lists/* 2>/dev/null
        print_status "INFO" "Updating package lists..."
        apt-get update -qq > /dev/null 2>&1
        
        print_status "OK" "Mirror updated successfully!"
    fi
    
    press_enter
}

#==============================================================================
# System Benchmark
#==============================================================================

run_benchmark() {
    print_header "SYSTEM BENCHMARK"
    
    echo -e "${YELLOW}Running comprehensive benchmark...${NC}\n"
    echo -e "${CYAN}This may take a few minutes${NC}\n"
    
    # Run bench.sh
    curl -Lso- bench.sh 2>/dev/null | bash
    
    press_enter
}

#==============================================================================
# Main Menu
#==============================================================================

main_menu() {
    while true; do
        print_banner
        show_system_info
        
        echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
        echo -e "${CYAN}${BOLD}                      MAIN MENU                            ${NC}"
        echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
        
        echo -e "${WHITE}  1)${NC} ğŸŒ Network & Server Optimization"
        echo -e "${WHITE}  2)${NC} ğŸ” Check IP Reputation & Security"
        echo -e "${WHITE}  3)${NC} ğŸ“Š System Benchmark"
        echo -e "${WHITE}  4)${NC} ğŸ”„ Optimize Repository Mirrors"
        echo -e "${WHITE}  0)${NC} âŒ Exit"
        
        echo -e "\n${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
        
        read -p "$(echo -e ${YELLOW}Select option:${NC} )" choice
        
        case $choice in
            1) network_optimization_menu ;;
            2) check_ip_reputation ;;
            3) run_benchmark ;;
            4) optimize_mirrors ;;
            0) 
                echo -e "\n${GREEN}Thank you for using Server Management Tool!${NC}\n"
                exit 0
                ;;
            *)
                print_status "FAIL" "Invalid option"
                sleep 1
                ;;
        esac
    done
}

#==============================================================================
# Main Execution
#==============================================================================

# Check root
check_root

# Detect OS
detect_os

# Start
main_menu
