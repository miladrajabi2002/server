#!/usr/bin/env bash
#==============================================================================
# Server Management & Optimization Tool
# Version: 3.0.0 - Modern Professional Edition
# Focus: Network Optimization, Performance, Server Management & Logs
#==============================================================================

# Color codes - Enhanced Professional Palette
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

# Configuration
SCRIPT_VERSION="3.0.0"
SYSCTL_CONF="/etc/sysctl.conf"
BACKUP_DIR="/root/server-tool-backups"

# Create backup directory
mkdir -p "$BACKUP_DIR"

#==============================================================================
# Utility Functions - Modern Design
#==============================================================================

print_banner() {
    clear
    echo -e "${CYAN}${BOLD}"
    cat << "EOF"
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                                                                
        âš¡ SERVER MANAGEMENT & OPTIMIZATION TOOL âš¡              
                   Professional Edition v3.0                    
                                                                
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
EOF
    echo -e "${NC}"
}

print_header() {
    echo -e "\n${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    printf "${CYAN}${BOLD}  â–¸ %-57s${NC}\n" "$1"
    echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
}

print_section() {
    echo -e "\n${BLUE}${BOLD}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
    printf "${BLUE}${BOLD}â”‚${NC} ${BOLD}%-59s${NC} ${BLUE}${BOLD}â”‚${NC}\n" "$1"
    echo -e "${BLUE}${BOLD}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}\n"
}

print_status() {
    local status="$1"
    local message="$2"
    
    case $status in
        "OK"|"SUCCESS")
            echo -e "${GREEN}  âœ“${NC} $message"
            ;;
        "WARN"|"WARNING")
            echo -e "${YELLOW}  âš ${NC} $message"
            ;;
        "FAIL"|"ERROR")
            echo -e "${RED}  âœ—${NC} $message"
            ;;
        "INFO")
            echo -e "${CYAN}  â–¸${NC} $message"
            ;;
        "PROCESS")
            echo -e "${MAGENTA}  â—†${NC} $message"
            ;;
    esac
}

# Enhanced progress bar with percentage and status
show_progress() {
    local current=$1
    local total=$2
    local status="${3:-Processing}"
    local width=40
    local percentage=$((current * 100 / total))
    local filled=$((width * current / total))
    local empty=$((width - filled))
    
    printf "\r  ${DIM}["
    printf "${GREEN}%${filled}s" | tr ' ' 'â–ˆ'
    printf "${GRAY}%${empty}s" | tr ' ' 'â–‘'
    printf "${DIM}]${NC} ${BOLD}%3d%%${NC} ${CYAN}%s${NC}" "$percentage" "$status"
}

# Loading animation
show_loading() {
    local message="$1"
    local pid=$2
    local delay=0.1
    local spinstr='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
    
    while kill -0 $pid 2>/dev/null; do
        local temp=${spinstr#?}
        printf "\r  ${CYAN}%c${NC} %s" "$spinstr" "$message"
        spinstr=$temp${spinstr%"$temp"}
        sleep $delay
    done
    printf "\r"
}

check_root() {
    if [ "$(id -u)" != "0" ]; then
        echo -e "${RED}${BOLD}âœ— Error:${NC} This script must be run as root or with sudo"
        echo -e "${YELLOW}  â–¸ Try: ${CYAN}sudo $0${NC}"
        exit 1
    fi
}

detect_os() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS=$ID
        OS_VERSION=$VERSION_ID
    else
        OS=$(uname -s)
        OS_VERSION=$(uname -r)
    fi
}

backup_file() {
    local file="$1"
    if [ -f "$file" ]; then
        cp "$file" "$BACKUP_DIR/$(basename $file).backup.$(date +%Y%m%d-%H%M%S)"
        print_status "INFO" "Backup created: $(basename $file)"
    fi
}

press_enter() {
    echo ""
    echo -ne "${DIM}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"
    echo -ne "${CYAN}Press ${BOLD}Enter${NC}${CYAN} to continue...${NC}"
    read
}

#==============================================================================
# System Information - Modern Card Design
#==============================================================================

show_system_info() {
    print_section "SYSTEM OVERVIEW"
    
    # Gather information
    HOSTNAME=$(hostname)
    KERNEL=$(uname -r)
    CPU_MODEL=$(lscpu | grep "Model name" | cut -d':' -f2 | xargs)
    CPU_CORES=$(nproc)
    TOTAL_MEM=$(free -h | awk '/^Mem:/ {print $2}')
    USED_MEM=$(free -h | awk '/^Mem:/ {print $3}')
    MEM_PERCENT=$(free | awk '/^Mem:/ {printf "%.0f", $3/$2 * 100}')
    TOTAL_DISK=$(df -h / | awk 'NR==2 {print $2}')
    USED_DISK=$(df -h / | awk 'NR==2 {print $3}')
    DISK_PERCENT=$(df / | awk 'NR==2 {print $5}' | tr -d '%')
    UPTIME=$(uptime -p 2>/dev/null || uptime | awk '{print $3,$4}' | tr -d ',')
    PUBLIC_IP=$(curl -s --max-time 3 https://api.ipify.org 2>/dev/null || echo "N/A")
    
    # Network info
    DNS_SERVERS=$(grep "^nameserver" /etc/resolv.conf 2>/dev/null | awk '{print $2}' | tr '\n' ', ' | sed 's/,$//' || echo "N/A")
    MAIN_INTERFACE=$(ip route | grep default | awk '{print $5}' | head -n1)
    MTU=$(ip link show $MAIN_INTERFACE 2>/dev/null | grep mtu | awk '{print $5}' || echo "N/A")
    RUNNING_PROCESSES=$(ps aux | wc -l)
    
    # Firewall
    if command -v ufw &> /dev/null; then
        FW_STATUS=$(ufw status 2>/dev/null | grep "Status:" | awk '{print $2}' || echo "N/A")
    elif command -v firewall-cmd &> /dev/null; then
        FW_STATUS=$(firewall-cmd --state 2>/dev/null || echo "N/A")
    elif systemctl is-active iptables &> /dev/null; then
        FW_STATUS="active"
    else
        FW_STATUS="inactive"
    fi
    
    # Color codes for status
    if [ "$MEM_PERCENT" -gt 80 ]; then MEM_COLOR="${RED}"; else MEM_COLOR="${GREEN}"; fi
    if [ "$DISK_PERCENT" -gt 80 ]; then DISK_COLOR="${RED}"; else DISK_COLOR="${GREEN}"; fi
    if [ "$FW_STATUS" = "active" ]; then FW_COLOR="${GREEN}"; else FW_COLOR="${YELLOW}"; fi
    
    # Display card
    echo -e "${BLUE}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
    printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} %-34s ${BLUE}â”‚${NC}\n" "Hostname" "$HOSTNAME"
    echo -e "${BLUE}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${NC}"
    printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} %-34s ${BLUE}â”‚${NC}\n" "Kernel" "$KERNEL"
    printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} %-34s ${BLUE}â”‚${NC}\n" "CPU" "${CPU_MODEL:0:34}"
    printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} ${CYAN}%-34s${NC} ${BLUE}â”‚${NC}\n" "CPU Cores" "$CPU_CORES cores"
    echo -e "${BLUE}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${NC}"
    printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} $MEM_COLOR%-34s${NC} ${BLUE}â”‚${NC}\n" "Memory Usage" "$USED_MEM / $TOTAL_MEM ($MEM_PERCENT%)"
    printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} $DISK_COLOR%-34s${NC} ${BLUE}â”‚${NC}\n" "Disk Usage" "$USED_DISK / $TOTAL_DISK ($DISK_PERCENT%)"
    echo -e "${BLUE}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${NC}"
    printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} ${CYAN}%-34s${NC} ${BLUE}â”‚${NC}\n" "Uptime" "${UPTIME:0:34}"
    printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} %-34s ${BLUE}â”‚${NC}\n" "Processes" "$RUNNING_PROCESSES"
    echo -e "${BLUE}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${NC}"
    printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} ${YELLOW}%-34s${NC} ${BLUE}â”‚${NC}\n" "Public IP" "$PUBLIC_IP"
    printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} %-34s ${BLUE}â”‚${NC}\n" "DNS Servers" "${DNS_SERVERS:0:34}"
    printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} %-34s ${BLUE}â”‚${NC}\n" "MTU ($MAIN_INTERFACE)" "$MTU"
    printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} $FW_COLOR%-34s${NC} ${BLUE}â”‚${NC}\n" "Firewall" "$FW_STATUS"
    echo -e "${BLUE}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
}

#==============================================================================
# TCP BBR Installation
#==============================================================================

install_bbr() {
    print_header "TCP BBR CONGESTION CONTROL"
    
    echo -e "${CYAN}â–¸ BBR (Bottleneck Bandwidth and RTT)${NC}"
    echo -e "${DIM}  Improves network throughput and reduces latency${NC}\n"
    
    # Check current
    current_cc=$(sysctl net.ipv4.tcp_congestion_control 2>/dev/null | awk '{print $3}')
    echo -e "  Current Algorithm: ${CYAN}${BOLD}$current_cc${NC}\n"
    
    if [ "$current_cc" = "bbr" ]; then
        print_status "SUCCESS" "BBR is already installed and active"
        press_enter
        return
    fi
    
    # Check kernel version
    kernel_version=$(uname -r | cut -d. -f1-2)
    major=$(echo $kernel_version | cut -d. -f1)
    minor=$(echo $kernel_version | cut -d. -f2)
    
    if [ "$major" -lt 4 ] || ([ "$major" -eq 4 ] && [ "$minor" -lt 9 ]); then
        print_status "ERROR" "BBR requires kernel 4.9+. Current: $(uname -r)"
        echo -e "${YELLOW}  â–¸ Please upgrade your kernel first${NC}"
        press_enter
        return
    fi
    
    print_status "SUCCESS" "Kernel version compatible: $(uname -r)"
    echo ""
    
    # Simulate installation progress
    echo -e "${CYAN}${BOLD}Installation Progress:${NC}\n"
    
    # Backup
    backup_file "$SYSCTL_CONF"
    show_progress 1 4 "Backing up configuration"
    sleep 0.5
    echo ""
    
    # Remove old settings
    sed -i '/net.core.default_qdisc/d' "$SYSCTL_CONF"
    sed -i '/net.ipv4.tcp_congestion_control/d' "$SYSCTL_CONF"
    show_progress 2 4 "Cleaning old settings"
    sleep 0.5
    echo ""
    
    # Add BBR
    echo "" >> "$SYSCTL_CONF"
    echo "# BBR Congestion Control - Installed by Server Tool v3.0" >> "$SYSCTL_CONF"
    echo "net.core.default_qdisc=fq" >> "$SYSCTL_CONF"
    echo "net.ipv4.tcp_congestion_control=bbr" >> "$SYSCTL_CONF"
    show_progress 3 4 "Writing BBR configuration"
    sleep 0.5
    echo ""
    
    # Apply
    sysctl -p > /dev/null 2>&1
    show_progress 4 4 "Applying settings"
    sleep 0.5
    echo ""
    
    # Verify
    echo ""
    if sysctl net.ipv4.tcp_congestion_control | grep -q "bbr"; then
        print_status "SUCCESS" "BBR installed and activated successfully!"
        echo ""
        print_status "INFO" "Changes will persist after reboot"
    else
        print_status "ERROR" "Failed to activate BBR"
    fi
    
    press_enter
}

#==============================================================================
# TCP Hybla Installation
#==============================================================================

install_hybla() {
    print_header "TCP HYBLA CONGESTION CONTROL"
    
    echo -e "${CYAN}â–¸ Hybla Algorithm${NC}"
    echo -e "${DIM}  Optimized for high-latency networks (satellite, long-distance)${NC}\n"
    
    # Check current
    current_cc=$(sysctl net.ipv4.tcp_congestion_control 2>/dev/null | awk '{print $3}')
    echo -e "  Current Algorithm: ${CYAN}${BOLD}$current_cc${NC}\n"
    
    if [ "$current_cc" = "hybla" ]; then
        print_status "SUCCESS" "Hybla is already installed and active"
        press_enter
        return
    fi
    
    # Load module
    echo -e "${CYAN}${BOLD}Installation Progress:${NC}\n"
    
    modprobe tcp_hybla 2>/dev/null
    show_progress 1 4 "Loading Hybla kernel module"
    sleep 0.5
    echo ""
    
    if ! lsmod | grep -q tcp_hybla; then
        print_status "ERROR" "Cannot load tcp_hybla module"
        echo -e "${YELLOW}  â–¸ Your kernel may not support Hybla${NC}"
        press_enter
        return
    fi
    
    print_status "SUCCESS" "Hybla module loaded successfully"
    echo ""
    
    # Persistent module
    if ! grep -q "tcp_hybla" /etc/modules 2>/dev/null; then
        echo "tcp_hybla" >> /etc/modules
    fi
    show_progress 2 4 "Configuring auto-load on boot"
    sleep 0.5
    echo ""
    
    # Backup
    backup_file "$SYSCTL_CONF"
    
    # Remove old settings
    sed -i '/net.core.default_qdisc/d' "$SYSCTL_CONF"
    sed -i '/net.ipv4.tcp_congestion_control/d' "$SYSCTL_CONF"
    show_progress 3 4 "Writing configuration"
    sleep 0.5
    echo ""
    
    # Add Hybla
    echo "" >> "$SYSCTL_CONF"
    echo "# Hybla Congestion Control - Installed by Server Tool v3.0" >> "$SYSCTL_CONF"
    echo "net.core.default_qdisc=fq" >> "$SYSCTL_CONF"
    echo "net.ipv4.tcp_congestion_control=hybla" >> "$SYSCTL_CONF"
    
    # Apply
    sysctl -p > /dev/null 2>&1
    show_progress 4 4 "Applying settings"
    sleep 0.5
    echo ""
    
    # Verify
    echo ""
    if sysctl net.ipv4.tcp_congestion_control | grep -q "hybla"; then
        print_status "SUCCESS" "Hybla installed and activated successfully!"
        echo ""
        print_status "INFO" "Changes will persist after reboot"
    else
        print_status "ERROR" "Failed to activate Hybla"
    fi
    
    press_enter
}

#==============================================================================
# Remove TCP Optimization
#==============================================================================

remove_tcp_optimization() {
    print_header "REMOVE TCP OPTIMIZATION"
    
    echo -e "${YELLOW}âš  This will remove BBR/Hybla and restore default settings${NC}\n"
    
    echo -ne "${RED}${BOLD}Are you sure?${NC} [y/N]: "
    read confirm
    if [[ ! $confirm =~ ^[Yy]$ ]]; then
        return
    fi
    
    echo ""
    echo -e "${CYAN}${BOLD}Removal Progress:${NC}\n"
    
    # Backup
    backup_file "$SYSCTL_CONF"
    show_progress 1 3 "Backing up configuration"
    sleep 0.5
    echo ""
    
    # Remove settings
    sed -i '/# BBR Congestion Control/d' "$SYSCTL_CONF"
    sed -i '/# Hybla Congestion Control/d' "$SYSCTL_CONF"
    sed -i '/net.core.default_qdisc/d' "$SYSCTL_CONF"
    sed -i '/net.ipv4.tcp_congestion_control/d' "$SYSCTL_CONF"
    show_progress 2 3 "Removing TCP optimization"
    sleep 0.5
    echo ""
    
    # Restore default (cubic)
    sysctl -w net.ipv4.tcp_congestion_control=cubic > /dev/null 2>&1
    sed -i '/tcp_hybla/d' /etc/modules 2>/dev/null
    show_progress 3 3 "Restoring defaults"
    sleep 0.5
    echo ""
    
    echo ""
    print_status "SUCCESS" "TCP optimization removed"
    print_status "INFO" "Default algorithm (cubic) restored"
    
    press_enter
}

#==============================================================================
# MTU Finder & Optimizer
#==============================================================================

mtu_finder() {
    print_header "MTU PATH DISCOVERY & OPTIMIZATION"
    
    # Get primary interface
    PRIMARY_IFACE=$(ip route | grep default | awk '{print $5}' | head -1)
    
    if [ -z "$PRIMARY_IFACE" ]; then
        print_status "ERROR" "Cannot detect primary network interface"
        press_enter
        return
    fi
    
    current_mtu=$(ip link show "$PRIMARY_IFACE" 2>/dev/null | grep -oP 'mtu \K\d+' || echo "1500")
    current_dns=$(grep -m1 "^nameserver" /etc/resolv.conf 2>/dev/null | awk '{print $2}')
    
    echo -e "${BLUE}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
    printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} ${CYAN}%-34s${NC} ${BLUE}â”‚${NC}\n" "Interface" "$PRIMARY_IFACE"
    printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} ${CYAN}%-34s${NC} ${BLUE}â”‚${NC}\n" "Current MTU" "$current_mtu"
    if [ -n "$current_dns" ]; then
        printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} ${CYAN}%-34s${NC} ${BLUE}â”‚${NC}\n" "Current DNS" "$current_dns"
    fi
    echo -e "${BLUE}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}\n"
    
    echo -e "${CYAN}${BOLD}Select Test Destination:${NC}\n"
    echo -e "  ${BOLD}1${NC}) ğŸŒ Google DNS (8.8.8.8)"
    echo -e "  ${BOLD}2${NC}) âš¡ Cloudflare DNS (1.1.1.1)"
    
    if [ -n "$current_dns" ]; then
        echo -e "  ${BOLD}3${NC}) ğŸ”§ Current Server DNS ($current_dns)"
        echo -e "  ${BOLD}4${NC}) ğŸ“ Custom IP Address"
        echo -e "  ${BOLD}0${NC}) â† Back"
    else
        echo -e "  ${BOLD}3${NC}) ğŸ“ Custom IP Address"
        echo -e "  ${BOLD}0${NC}) â† Back"
    fi
    
    echo ""
    echo -ne "${YELLOW}Your choice: ${NC}"
    read dest_choice
    
    if [ -n "$current_dns" ]; then
        case $dest_choice in
            1) test_ip="8.8.8.8" ;;
            2) test_ip="1.1.1.1" ;;
            3) test_ip="$current_dns" ;;
            4) echo -ne "${CYAN}Enter IP address: ${NC}"; read test_ip ;;
            0) return ;;
            *) print_status "ERROR" "Invalid choice"; press_enter; return ;;
        esac
    else
        case $dest_choice in
            1) test_ip="8.8.8.8" ;;
            2) test_ip="1.1.1.1" ;;
            3) echo -ne "${CYAN}Enter IP address: ${NC}"; read test_ip ;;
            0) return ;;
            *) print_status "ERROR" "Invalid choice"; press_enter; return ;;
        esac
    fi
    
    # Test connectivity
    echo ""
    echo -ne "${DIM}Testing connectivity to $test_ip...${NC}\r"
    
    if ! ping -c 1 -W 2 "$test_ip" &>/dev/null; then
        print_status "ERROR" "Cannot reach $test_ip                    "
        press_enter
        return
    fi
    
    print_status "SUCCESS" "Target $test_ip is reachable                    "
    echo ""
    
    print_section "MTU DISCOVERY - BINARY SEARCH ALGORITHM"
    
    # Binary Search
    local low=1200
    local high=1500
    local optimal=1200
    local test_count=0
    
    while [ $low -le $high ]; do
        local mid=$(( (low + high) / 2 ))
        local payload=$((mid - 28))
        test_count=$((test_count + 1))
        
        show_progress $test_count 12 "Testing MTU $mid (payload $payload)"
        
        local success=0
        for attempt in 1 2 3; do
            if ping -M do -c 1 -s $payload -W 2 "$test_ip" &>/dev/null; then
                success=1
                break
            fi
            sleep 0.1
        done
        
        if [ $success -eq 1 ]; then
            optimal=$mid
            low=$((mid + 1))
        else
            high=$((mid - 1))
        fi
    done
    
    echo ""
    echo ""
    
    print_section "FINE-TUNING OPTIMAL MTU"
    
    for fine_mtu in $((optimal + 1)) $((optimal + 2)) $((optimal + 3)); do
        [ $fine_mtu -gt 1500 ] && break
        
        local payload=$((fine_mtu - 28))
        
        if ping -M do -c 2 -s $payload -W 2 "$test_ip" &>/dev/null; then
            optimal=$fine_mtu
            print_status "SUCCESS" "MTU $fine_mtu: PASS"
        else
            print_status "FAIL" "MTU $fine_mtu: FAIL"
            break
        fi
    done
    
    # Results
    local recommended_mtu=$((optimal - 10))
    [ $recommended_mtu -lt 1280 ] && recommended_mtu=1280
    
    echo ""
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${GREEN}${BOLD}  âœ“ MTU DISCOVERY COMPLETED${NC}"
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"
    
    echo -e "${BLUE}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
    printf "${BLUE}â”‚${NC} ${BOLD}%-25s${NC} ${BLUE}â”‚${NC} ${GREEN}${BOLD}%-29s${NC} ${BLUE}â”‚${NC}\n" "Maximum Working MTU" "$optimal bytes"
    printf "${BLUE}â”‚${NC} ${BOLD}%-25s${NC} ${BLUE}â”‚${NC} ${CYAN}${BOLD}%-29s${NC} ${BLUE}â”‚${NC}\n" "Recommended Safe MTU" "$recommended_mtu bytes"
    echo -e "${BLUE}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}\n"
    
    echo -e "${YELLOW}${BOLD}Why Recommended MTU is Lower:${NC}"
    echo -e "${DIM}  â€¢ Allows for VPN/tunnel overhead (if used)"
    echo -e "  â€¢ Prevents fragmentation in diverse network paths"
    echo -e "  â€¢ Industry best practice for reliability${NC}\n"
    
    echo -ne "${YELLOW}${BOLD}Apply recommended MTU (${recommended_mtu})?${NC} [y/N]: "
    read apply_mtu
    
    if [[ $apply_mtu =~ ^[Yy]$ ]]; then
        echo ""
        ip link set dev "$PRIMARY_IFACE" mtu "$recommended_mtu" 2>/dev/null
        print_status "SUCCESS" "MTU temporarily set to $recommended_mtu"
        
        # Configuration instructions
        echo ""
        print_section "MAKING CHANGES PERMANENT"
        
        if ls /etc/netplan/*.yaml &>/dev/null; then
            echo -e "${CYAN}â–¸ Netplan detected (Ubuntu/Debian)${NC}\n"
            echo -e "  ${BOLD}1.${NC} Edit netplan config:"
            echo -e "     ${CYAN}sudo nano /etc/netplan/*.yaml${NC}\n"
            echo -e "  ${BOLD}2.${NC} Add under 'ethernets: $PRIMARY_IFACE:':"
            echo -e "     ${GREEN}mtu: $recommended_mtu${NC}\n"
            echo -e "  ${BOLD}3.${NC} Apply changes:"
            echo -e "     ${CYAN}sudo netplan apply${NC}\n"
        else
            echo -e "${CYAN}â–¸ Manual configuration required${NC}\n"
            echo -e "  ${CYAN}ip link set dev $PRIMARY_IFACE mtu $recommended_mtu${NC}\n"
        fi
        
        new_mtu=$(ip link show "$PRIMARY_IFACE" 2>/dev/null | grep -oP 'mtu \K\d+')
        if [ "$new_mtu" = "$recommended_mtu" ]; then
            print_status "SUCCESS" "Verified: MTU is now $new_mtu"
        fi
    fi
    
    press_enter
}

#==============================================================================
# DNS Optimizer
#==============================================================================

optimize_dns() {
    print_header "DNS OPTIMIZER & BENCHMARK"
    
    # Check dig
    if ! command -v dig &>/dev/null; then
        echo -e "${YELLOW}âš  dig tool not found. Installing...${NC}\n"
        
        if command -v apt-get &>/dev/null; then
            apt-get update -qq && apt-get install -y dnsutils &>/dev/null
        elif command -v yum &>/dev/null; then
            yum install -y bind-utils &>/dev/null
        fi
        
        if command -v dig &>/dev/null; then
            print_status "SUCCESS" "dig installed successfully"
        else
            print_status "ERROR" "Could not install dig"
        fi
        echo ""
    fi
    
    print_section "TESTING DNS SERVERS"
    
    # DNS servers
    declare -A dns_servers=(
        ["Google-1"]="8.8.8.8"
        ["Google-2"]="8.8.4.4"
        ["Cloudflare-1"]="1.1.1.1"
        ["Cloudflare-2"]="1.0.0.1"
        ["Quad9"]="9.9.9.9"
        ["OpenDNS-1"]="208.67.222.222"
        ["OpenDNS-2"]="208.67.220.220"
        ["Shecan-1"]="178.22.122.100"
        ["Shecan-2"]="185.51.200.2"
    )
    
    declare -A dns_display_names=(
        ["Google-1"]="Google Primary"
        ["Google-2"]="Google Secondary"
        ["Cloudflare-1"]="Cloudflare Primary"
        ["Cloudflare-2"]="Cloudflare Secondary"
        ["Quad9"]="Quad9"
        ["OpenDNS-1"]="OpenDNS Primary"
        ["OpenDNS-2"]="OpenDNS Secondary"
        ["Shecan-1"]="Shecan Primary"
        ["Shecan-2"]="Shecan Secondary"
    )
    
    local test_domains=("google.com" "youtube.com" "facebook.com" "amazon.com" "wikipedia.org")
    
    declare -A dns_avg_times
    declare -A dns_success_rate
    
    local total=${#dns_servers[@]}
    local count=0
    
    for key in "${!dns_servers[@]}"; do
        ip="${dns_servers[$key]}"
        display_name="${dns_display_names[$key]}"
        count=$((count + 1))
        
        show_progress $count $total "Testing $display_name"
        
        local total_time=0
        local success_count=0
        
        if command -v dig &>/dev/null; then
            for domain in "${test_domains[@]}"; do
                response_time=$(dig @$ip $domain +stats +timeout=2 +tries=1 2>/dev/null | grep "Query time:" | awk '{print $4}')
                
                if [ -n "$response_time" ] && [ "$response_time" -gt 0 ] 2>/dev/null; then
                    total_time=$((total_time + response_time))
                    success_count=$((success_count + 1))
                fi
            done
        fi
        
        if [ $success_count -gt 0 ]; then
            avg_time=$((total_time / success_count))
            success_rate=$((success_count * 100 / ${#test_domains[@]}))
            
            dns_avg_times["$key"]="$avg_time"
            dns_success_rate["$key"]="$success_rate"
        else
            dns_avg_times["$key"]="9999"
            dns_success_rate["$key"]="0"
        fi
        
        sleep 0.1
    done
    
    echo ""
    echo ""
    
    # Find fastest
    fastest_key=""
    fastest_time=999999
    
    for key in "${!dns_avg_times[@]}"; do
        time="${dns_avg_times[$key]}"
        rate="${dns_success_rate[$key]}"
        
        if [ -n "$rate" ] && [ -n "$time" ] && [ "$rate" -ge 80 ] 2>/dev/null && [ "$time" -lt "$fastest_time" ] 2>/dev/null; then
            fastest_time=$time
            fastest_key=$key
        fi
    done
    
    if [ -z "$fastest_key" ]; then
        print_status "ERROR" "No reliable DNS servers found"
        press_enter
        return
    fi
    
    fastest_ip="${dns_servers[$fastest_key]}"
    fastest_name="${dns_display_names[$fastest_key]}"
    
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${GREEN}${BOLD}  âœ“ FASTEST DNS FOUND${NC}"
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"
    
    echo -e "${GREEN}  ğŸ† ${BOLD}$fastest_name${NC} ${GREEN}($fastest_ip)${NC}"
    echo -e "${GREEN}     Response Time: ${BOLD}${fastest_time}ms${NC}\n"
    
    print_section "DNS RANKING"
    
    # Sort and display
    declare -a sorted_keys
    while IFS= read -r key; do
        sorted_keys+=("$key")
    done < <(
        for key in "${!dns_avg_times[@]}"; do
            printf "%s\t%s\t%s\n" "$key" "${dns_avg_times[$key]}" "${dns_success_rate[$key]}"
        done | sort -t$'\t' -k2 -n | cut -f1
    )
    
    local rank=1
    for key in "${sorted_keys[@]}"; do
        [ -z "$key" ] && continue
        
        display_name="${dns_display_names[$key]}"
        ip="${dns_servers[$key]}"
        time="${dns_avg_times[$key]}"
        rate="${dns_success_rate[$key]}"
        
        [ "$time" = "9999" ] && continue
        
        if [ "$key" = "$fastest_key" ]; then
            echo -e "  ${GREEN}${BOLD}$rank. âœ“ $display_name${NC} ${GREEN}($ip)${NC}"
            echo -e "     ${GREEN}${time}ms${NC} â€¢ ${GREEN}${rate}% reliability${NC}"
        elif [ -n "$rate" ] && [ "$rate" -ge 80 ] 2>/dev/null; then
            echo -e "  ${CYAN}$rank.   $display_name${NC} ${DIM}($ip)${NC}"
            echo -e "     ${CYAN}${time}ms${NC} â€¢ ${rate}% reliability"
        else
            echo -e "  ${YELLOW}$rank.   $display_name${NC} ${DIM}($ip)${NC}"
            echo -e "     ${YELLOW}${time}ms${NC} â€¢ ${RED}${rate}% reliability (Unreliable)${NC}"
        fi
        echo ""
        rank=$((rank + 1))
    done
    
    # Find second best
    second_key=""
    second_time=999999
    
    for key in "${sorted_keys[@]}"; do
        [ -z "$key" ] && continue
        [ "$key" = "$fastest_key" ] && continue
        
        time="${dns_avg_times[$key]}"
        rate="${dns_success_rate[$key]}"
        
        if [ -n "$rate" ] && [ -n "$time" ] && [ "$rate" -ge 80 ] 2>/dev/null && [ "$time" -lt "$second_time" ] 2>/dev/null; then
            second_time=$time
            second_key=$key
        fi
    done
    
    if [ -n "$second_key" ]; then
        second_ip="${dns_servers[$second_key]}"
        second_name="${dns_display_names[$second_key]}"
    else
        second_ip="8.8.8.8"
        second_name="Google (fallback)"
    fi
    
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"
    
    echo -e "${YELLOW}${BOLD}Recommended Configuration:${NC}\n"
    echo -e "  ${BOLD}Primary DNS:${NC}   ${CYAN}$fastest_ip${NC} ($fastest_name)"
    echo -e "  ${BOLD}Secondary DNS:${NC} ${CYAN}$second_ip${NC} ($second_name)\n"
    
    echo -ne "${YELLOW}${BOLD}Apply these DNS settings?${NC} [y/N]: "
    read apply_dns
    
    if [[ $apply_dns =~ ^[Yy]$ ]]; then
        echo ""
        backup_file "/etc/resolv.conf"
        
        chattr -i /etc/resolv.conf 2>/dev/null || true
        
        cat > /etc/resolv.conf << EOF
# DNS Configuration - Auto-configured by Server Tool v3.0
# Fastest DNS: $fastest_name (${fastest_time}ms avg)
nameserver $fastest_ip
nameserver $second_ip
nameserver 8.8.8.8
EOF
        
        chattr +i /etc/resolv.conf 2>/dev/null || true
        
        print_status "SUCCESS" "DNS configuration updated"
        print_status "INFO" "Primary: $fastest_name ($fastest_ip)"
        [ -n "$second_key" ] && print_status "INFO" "Secondary: $second_name ($second_ip)"
        
        echo ""
        if nslookup google.com &>/dev/null || host google.com &>/dev/null; then
            print_status "SUCCESS" "DNS is working correctly"
        else
            print_status "WARN" "DNS test failed - please verify manually"
        fi
    fi
    
    press_enter
}

#==============================================================================
# Block/Unblock ICMP
#==============================================================================

manage_ping() {
    print_header "ICMP PING MANAGEMENT"
    
    current_setting=$(sysctl net.ipv4.icmp_echo_ignore_all 2>/dev/null | awk '{print $3}')
    
    echo -e "${BLUE}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
    if [ "$current_setting" = "1" ]; then
        printf "${BLUE}â”‚${NC} ${BOLD}Current Status:${NC} ${RED}%-40s${NC} ${BLUE}â”‚${NC}\n" "ğŸ”´ PING BLOCKED"
    else
        printf "${BLUE}â”‚${NC} ${BOLD}Current Status:${NC} ${GREEN}%-40s${NC} ${BLUE}â”‚${NC}\n" "ğŸŸ¢ PING ALLOWED"
    fi
    echo -e "${BLUE}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}\n"
    
    echo -e "  ${BOLD}1${NC}) ğŸ›¡ï¸  Block Ping (Hide server)"
    echo -e "  ${BOLD}2${NC}) âœ… Unblock Ping (Allow ICMP)"
    echo -e "  ${BOLD}0${NC}) â† Back"
    echo ""
    echo -ne "${YELLOW}Your choice: ${NC}"
    read ping_choice
    
    case $ping_choice in
        1)
            backup_file "$SYSCTL_CONF"
            sed -i '/net.ipv4.icmp_echo_ignore_all/d' "$SYSCTL_CONF"
            echo "net.ipv4.icmp_echo_ignore_all=1" >> "$SYSCTL_CONF"
            sysctl -w net.ipv4.icmp_echo_ignore_all=1 > /dev/null 2>&1
            echo ""
            print_status "SUCCESS" "Ping blocked successfully"
            print_status "INFO" "Setting will persist after reboot"
            ;;
        2)
            backup_file "$SYSCTL_CONF"
            sed -i '/net.ipv4.icmp_echo_ignore_all/d' "$SYSCTL_CONF"
            echo "net.ipv4.icmp_echo_ignore_all=0" >> "$SYSCTL_CONF"
            sysctl -w net.ipv4.icmp_echo_ignore_all=0 > /dev/null 2>&1
            echo ""
            print_status "SUCCESS" "Ping unblocked successfully"
            print_status "INFO" "Setting will persist after reboot"
            ;;
        0)
            return
            ;;
        *)
            print_status "ERROR" "Invalid choice"
            ;;
    esac
    
    press_enter
}

#==============================================================================
# Complete Server Optimization
#==============================================================================

optimize_server() {
    print_header "COMPLETE SERVER OPTIMIZATION"
    
    echo -e "${YELLOW}âš  This will apply comprehensive system optimizations${NC}"
    echo -e "${DIM}  Including: Memory, Network, File System, and Security${NC}\n"
    
    echo -ne "${RED}${BOLD}Continue?${NC} [y/N]: "
    read confirm
    if [[ ! $confirm =~ ^[Yy]$ ]]; then
        return
    fi
    
    echo ""
    print_section "OPTIMIZATION PROGRESS"
    
    # Backup
    backup_file "$SYSCTL_CONF"
    backup_file "/etc/security/limits.conf"
    show_progress 1 5 "Backing up configurations"
    sleep 0.5
    echo ""
    
    # Create sysctl.conf
    cat > "$SYSCTL_CONF" << 'EOF'
# Server Optimization Configuration
# Generated by Server Management Tool v3.0

# Memory Management
vm.swappiness=10
vm.dirty_ratio=20
vm.dirty_background_ratio=10

# File System
fs.file-max=2097152

# Network Core
net.core.somaxconn=4096
net.core.netdev_max_backlog=16384

# IPv4 Network
net.ipv4.ip_local_port_range=1024 65535
net.ipv4.ip_nonlocal_bind=1

# TCP Configuration
net.ipv4.tcp_fin_timeout=15
net.ipv4.tcp_keepalive_time=300
net.ipv4.tcp_syncookies=0
net.ipv4.tcp_max_orphans=262144
net.ipv4.tcp_max_syn_backlog=8192
net.ipv4.tcp_max_tw_buckets=262144
net.ipv4.tcp_reordering=3

# TCP Memory
net.ipv4.tcp_mem=786432 1697152 1945728
net.ipv4.tcp_rmem=4096 87380 16777216
net.ipv4.tcp_wmem=4096 65536 16777216

# TCP Retries
net.ipv4.tcp_syn_retries=5

# TCP Reuse
net.ipv4.tcp_tw_reuse=1
EOF
    
    show_progress 2 5 "Writing kernel parameters"
    sleep 0.5
    echo ""
    
    # Create limits.conf
    cat > /etc/security/limits.conf << 'EOF'
# System Limits Configuration
# Generated by Server Management Tool v3.0

* soft nproc 65535
* hard nproc 65535
* soft nofile 1048576
* hard nofile 1048576

root soft nproc 65535
root hard nproc 65535
root soft nofile 1048576
root hard nofile 1048576
EOF
    
    show_progress 3 5 "Writing system limits"
    sleep 0.5
    echo ""
    
    # Apply sysctl
    sysctl -p > /dev/null 2>&1
    show_progress 4 5 "Applying kernel parameters"
    sleep 0.5
    echo ""
    
    show_progress 5 5 "Finalizing optimization"
    sleep 0.5
    echo ""
    
    echo ""
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${GREEN}${BOLD}  âœ“ OPTIMIZATION COMPLETED${NC}"
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"
    
    echo -e "${GREEN}Applied Optimizations:${NC}\n"
    echo -e "  ${GREEN}âœ“${NC} Memory management (swappiness, dirty ratio)"
    echo -e "  ${GREEN}âœ“${NC} File system limits (file-max)"
    echo -e "  ${GREEN}âœ“${NC} Network buffers and backlog"
    echo -e "  ${GREEN}âœ“${NC} TCP parameters (timeouts, memory)"
    echo -e "  ${GREEN}âœ“${NC} Process and file descriptor limits\n"
    
    print_status "INFO" "All settings will persist after reboot"
    print_status "INFO" "Backups saved in: $BACKUP_DIR"
    
    press_enter
}

#==============================================================================
# Server Monitoring
#==============================================================================

monitoring() {
    print_header "LIVE SERVER MONITORING"
    
    if ! command -v btop &>/dev/null; then
        echo -e "${YELLOW}âš  btop not found. Installing...${NC}\n"
        
        if apt-get update -qq && apt-get install -y btop &>/dev/null; then
            print_status "SUCCESS" "btop installed successfully"
        else
            print_status "WARN" "Failed to install btop, using htop/top instead"
            apt-get install -y htop &>/dev/null && htop || top
            press_enter
            return
        fi
    fi
    
    btop
    press_enter
}

#==============================================================================
# IP Reputation Check
#==============================================================================

check_ip_reputation() {
    print_header "IP REPUTATION & SECURITY ANALYSIS"
    
    echo -ne "${CYAN}â–¸ Fetching your public IP address...${NC}\r"
    PUBLIC_IP=$(curl -s --max-time 8 https://api.ipify.org 2>/dev/null || echo "N/A")
    
    if [ "$PUBLIC_IP" = "N/A" ]; then
        print_status "ERROR" "Cannot retrieve public IP address"
        press_enter
        return
    fi
    
    echo -e "${GREEN}  âœ“ Your Public IP: ${YELLOW}${BOLD}$PUBLIC_IP${NC}                    \n"
    
    local total_checks=0
    local passed_checks=0
    local critical_issues=0
    
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${CYAN}${BOLD}  SECURITY ANALYSIS IN PROGRESS${NC}"
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"
    
    # Test 1: IP-API
    echo -e "${BOLD}[1/8] ğŸŒ IP Geolocation & ISP Analysis${NC}"
    echo -ne "${DIM}  â–¸ Checking...${NC}\r"
    
    ip_info=$(curl -s --max-time 8 "http://ip-api.com/json/$PUBLIC_IP?fields=status,country,city,isp,org,proxy,hosting" 2>/dev/null)
    
    if [ -n "$ip_info" ] && echo "$ip_info" | grep -q "success"; then
        country=$(echo "$ip_info" | grep -o '"country":"[^"]*' | cut -d'"' -f4)
        city=$(echo "$ip_info" | grep -o '"city":"[^"]*' | cut -d'"' -f4)
        isp=$(echo "$ip_info" | grep -o '"isp":"[^"]*' | cut -d'"' -f4)
        is_proxy=$(echo "$ip_info" | grep -o '"proxy":true' | wc -l)
        is_hosting=$(echo "$ip_info" | grep -o '"hosting":true' | wc -l)
        
        echo -e "  ${GREEN}âœ“${NC} Location: ${CYAN}$city, $country${NC}       "
        echo -e "  ${GREEN}âœ“${NC} ISP: ${CYAN}${isp:0:50}${NC}"
        
        total_checks=$((total_checks + 1))
        
        if [ $is_proxy -eq 0 ]; then
            passed_checks=$((passed_checks + 1))
            echo -e "  ${GREEN}âœ“${NC} Proxy Status: ${GREEN}Clean${NC}"
        else
            echo -e "  ${RED}âœ—${NC} Proxy Status: ${RED}Detected${NC}"
            critical_issues=$((critical_issues + 1))
        fi
        
        if [ $is_hosting -eq 1 ]; then
            echo -e "  ${YELLOW}âš ${NC} Type: ${YELLOW}Datacenter/VPS${NC}"
        else
            echo -e "  ${GREEN}âœ“${NC} Type: ${GREEN}Residential${NC}"
        fi
    else
        echo -e "  ${RED}âœ—${NC} Check failed       "
    fi
    echo ""
    
    # Test 2: IPQualityScore
    echo -e "${BOLD}[2/8] ğŸ” Fraud Detection Analysis${NC}"
    echo -ne "${DIM}  â–¸ Checking...${NC}\r"
    
    ipqs=$(curl -s --max-time 8 "https://www.ipqualityscore.com/api/json/ip/free/$PUBLIC_IP" 2>/dev/null)
    
    if [ -n "$ipqs" ]; then
        fraud=$(echo "$ipqs" | grep -o '"fraud_score":[0-9]*' | cut -d':' -f2)
        vpn=$(echo "$ipqs" | grep -o '"vpn":true' | wc -l)
        proxy=$(echo "$ipqs" | grep -o '"proxy":true' | wc -l)
        tor=$(echo "$ipqs" | grep -o '"tor":true' | wc -l)
        
        total_checks=$((total_checks + 1))
        
        if [ -n "$fraud" ]; then
            if [ "$fraud" -lt 50 ]; then
                passed_checks=$((passed_checks + 1))
                echo -e "  ${GREEN}âœ“${NC} Fraud Score: ${GREEN}${BOLD}$fraud/100${NC} ${GREEN}(Low Risk)${NC}       "
            elif [ "$fraud" -lt 75 ]; then
                echo -e "  ${YELLOW}âš ${NC} Fraud Score: ${YELLOW}${BOLD}$fraud/100${NC} ${YELLOW}(Medium Risk)${NC}"
            else
                echo -e "  ${RED}âœ—${NC} Fraud Score: ${RED}${BOLD}$fraud/100${NC} ${RED}(High Risk)${NC}"
                critical_issues=$((critical_issues + 1))
            fi
        fi
        
        [ $vpn -eq 0 ] && echo -e "  ${GREEN}âœ“${NC} VPN: ${GREEN}Not detected${NC}" || echo -e "  ${RED}âœ—${NC} VPN: ${RED}Detected${NC}"
        [ $proxy -eq 0 ] && echo -e "  ${GREEN}âœ“${NC} Proxy: ${GREEN}Not detected${NC}" || echo -e "  ${RED}âœ—${NC} Proxy: ${RED}Detected${NC}"
        [ $tor -eq 0 ] && echo -e "  ${GREEN}âœ“${NC} Tor: ${GREEN}Not detected${NC}" || echo -e "  ${RED}âœ—${NC} Tor: ${RED}Detected${NC}"
    else
        echo -e "  ${RED}âœ—${NC} Check failed       "
    fi
    echo ""
    
    # Test 3: Shodan
    echo -e "${BOLD}[3/8] ğŸ”“ Port & Vulnerability Scanner${NC}"
    echo -ne "${DIM}  â–¸ Checking...${NC}\r"
    
    shodan=$(curl -s --max-time 8 "https://internetdb.shodan.io/$PUBLIC_IP" 2>/dev/null)
    
    if [ -n "$shodan" ] && ! echo "$shodan" | grep -q "No information"; then
        ports=$(echo "$shodan" | grep -o '"ports":\[[^]]*\]' | grep -o '[0-9]*' | tr '\n' ',' | sed 's/,$//')
        vulns=$(echo "$shodan" | grep -o '"vulns":\[[^]]*\]' | grep -o 'CVE-[0-9-]*' | wc -l)
        
        if [ -n "$ports" ]; then
            echo -e "  ${YELLOW}âš ${NC} Open Ports: ${YELLOW}$ports${NC}       "
        else
            echo -e "  ${GREEN}âœ“${NC} No common ports exposed       "
        fi
        
        if [ "$vulns" -gt 0 ]; then
            echo -e "  ${RED}âœ—${NC} Vulnerabilities: ${RED}$vulns CVEs found${NC}"
            critical_issues=$((critical_issues + 1))
        else
            echo -e "  ${GREEN}âœ“${NC} No known vulnerabilities       "
        fi
    else
        echo -e "  ${GREEN}âœ“${NC} Not indexed (good)       "
    fi
    echo ""
    
    # Test 4: DNS Blacklists
    echo -e "${BOLD}[4/8] ğŸ“‹ DNS Blacklist Check${NC}"
    echo -ne "${DIM}  â–¸ Checking...${NC}\r"
    
    reversed_ip=$(echo "$PUBLIC_IP" | awk -F. '{print $4"."$3"."$2"."$1}')
    blacklisted=0
    bl_names=""
    
    for rbl in "zen.spamhaus.org" "bl.spamcop.net" "dnsbl.sorbs.net" "b.barracudacentral.org"; do
        if host "${reversed_ip}.${rbl}" &>/dev/null; then
            blacklisted=$((blacklisted + 1))
            bl_names="$bl_names$rbl "
        fi
    done
    
    total_checks=$((total_checks + 1))
    
    if [ $blacklisted -eq 0 ]; then
        passed_checks=$((passed_checks + 1))
        echo -e "  ${GREEN}âœ“${NC} Status: ${GREEN}Clean (0/4 lists)${NC}       "
    else
        echo -e "  ${RED}âœ—${NC} Status: ${RED}Listed in $blacklisted/4 lists${NC}"
        echo -e "  ${DIM}  $bl_names${NC}"
        critical_issues=$((critical_issues + 1))
    fi
    echo ""
    
    # Test 5: IPHub
    echo -e "${BOLD}[5/8] ğŸ›¡ï¸  Advanced Proxy Detection${NC}"
    echo -ne "${DIM}  â–¸ Checking...${NC}\r"
    
    iphub=$(curl -s --max-time 8 "http://v2.api.iphub.info/ip/$PUBLIC_IP" 2>/dev/null)
    
    if [ -n "$iphub" ]; then
        block=$(echo "$iphub" | grep -o '"block":[0-2]' | cut -d':' -f2)
        total_checks=$((total_checks + 1))
        
        case "$block" in
            0)
                passed_checks=$((passed_checks + 1))
                echo -e "  ${GREEN}âœ“${NC} Type: ${GREEN}Residential/Business IP${NC}       "
                ;;
            1)
                echo -e "  ${RED}âœ—${NC} Type: ${RED}Proxy/VPN detected${NC}"
                critical_issues=$((critical_issues + 1))
                ;;
            2)
                echo -e "  ${YELLOW}âš ${NC} Type: ${YELLOW}Hosting/Datacenter${NC}"
                ;;
        esac
    else
        echo -e "  ${YELLOW}âš ${NC} Check unavailable       "
    fi
    echo ""
    
    # Test 6: Scamalytics
    echo -e "${BOLD}[6/8] ğŸ¯ Scamalytics Fraud Score${NC}"
    echo -ne "${DIM}  â–¸ Checking...${NC}\r"
    
    scam=$(curl -s --max-time 8 "https://scamalytics.com/ip/$PUBLIC_IP" 2>/dev/null)
    
    if [ -n "$scam" ]; then
        fraud_scam=$(echo "$scam" | grep -o 'Fraud Score: [0-9]*' | grep -o '[0-9]*' | head -1)
        total_checks=$((total_checks + 1))
        
        if [ -n "$fraud_scam" ]; then
            if [ "$fraud_scam" -lt 25 ]; then
                passed_checks=$((passed_checks + 1))
                echo -e "  ${GREEN}âœ“${NC} Score: ${GREEN}${BOLD}$fraud_scam/100${NC} ${GREEN}(Very Low)${NC}       "
            elif [ "$fraud_scam" -lt 75 ]; then
                echo -e "  ${YELLOW}âš ${NC} Score: ${YELLOW}${BOLD}$fraud_scam/100${NC}"
            else
                echo -e "  ${RED}âœ—${NC} Score: ${RED}${BOLD}$fraud_scam/100${NC} ${RED}(High)${NC}"
                critical_issues=$((critical_issues + 1))
            fi
        else
            total_checks=$((total_checks - 1))
            echo -e "  ${YELLOW}âš ${NC} Could not parse       "
        fi
    else
        echo -e "  ${YELLOW}âš ${NC} Check failed       "
    fi
    echo ""
    
    # Test 7: GetIPIntel
    echo -e "${BOLD}[7/8] ğŸ“Š Proxy Probability Analysis${NC}"
    echo -ne "${DIM}  â–¸ Checking...${NC}\r"
    
    getip=$(curl -s --max-time 8 "http://check.getipintel.net/check.php?ip=$PUBLIC_IP&contact=admin@server.local&flags=b" 2>/dev/null)
    
    if [ -n "$getip" ] && [ "$getip" != "-1" ] && [ "$getip" != "-2" ]; then
        prob=$(echo "$getip" | awk '{printf "%.0f", $1 * 100}')
        total_checks=$((total_checks + 1))
        
        if [ "$prob" -lt 50 ]; then
            passed_checks=$((passed_checks + 1))
            echo -e "  ${GREEN}âœ“${NC} Probability: ${GREEN}${BOLD}${prob}%${NC} ${GREEN}(Low)${NC}       "
        elif [ "$prob" -lt 75 ]; then
            echo -e "  ${YELLOW}âš ${NC} Probability: ${YELLOW}${BOLD}${prob}%${NC}"
        else
            echo -e "  ${RED}âœ—${NC} Probability: ${RED}${BOLD}${prob}%${NC} ${RED}(High)${NC}"
            critical_issues=$((critical_issues + 1))
        fi
    else
        echo -e "  ${YELLOW}âš ${NC} Check unavailable       "
    fi
    echo ""
    
    # Test 8: AbuseIPDB
    echo -e "${BOLD}[8/8] ğŸš¨ Abuse Report Database${NC}"
    echo -ne "${DIM}  â–¸ Checking...${NC}\r"
    
    abuse_page=$(curl -s --max-time 8 "https://www.abuseipdb.com/check/$PUBLIC_IP" 2>/dev/null)
    total_checks=$((total_checks + 1))
    
    if echo "$abuse_page" | grep -qi "whitelisted\|not found\|clean\|0 reports"; then
        passed_checks=$((passed_checks + 1))
        echo -e "  ${GREEN}âœ“${NC} Status: ${GREEN}No abuse reports${NC}       "
    elif echo "$abuse_page" | grep -qi "reported\|blacklist"; then
        echo -e "  ${RED}âœ—${NC} Status: ${RED}Abuse reports found${NC}"
        critical_issues=$((critical_issues + 1))
    else
        echo -e "  ${YELLOW}âš ${NC} Could not verify${NC}"
        total_checks=$((total_checks - 1))
    fi
    echo ""
    
    # Final Score
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${CYAN}${BOLD}  FINAL REPUTATION ANALYSIS${NC}"
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"
    
    [ $total_checks -eq 0 ] && total_checks=1
    score=$((passed_checks * 100 / total_checks))
    
    # Progress bar for score
    filled=$((score / 2))
    empty=$((50 - filled))
    
    if [ $score -ge 80 ]; then
        color="${GREEN}"
        status="âœ“ CLEAN IP"
        emoji="ğŸŸ¢"
    elif [ $score -ge 60 ]; then
        color="${YELLOW}"
        status="âš  MODERATE"
        emoji="ğŸŸ¡"
    else
        color="${RED}"
        status="âœ— POOR REPUTATION"
        emoji="ğŸ”´"
    fi
    
    echo -e "${BOLD}Reputation Score:${NC}\n"
    echo -ne "  $color"
    printf 'â–ˆ%.0s' $(seq 1 $filled)
    echo -ne "${GRAY}"
    printf 'â–‘%.0s' $(seq 1 $empty)
    echo -e "${NC} ${BOLD}${score}%${NC}\n"
    
    echo -e "${BLUE}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
    printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} $color${BOLD}%-34s${NC} ${BLUE}â”‚${NC}\n" "Status" "$emoji $status"
    printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} ${GREEN}%-34s${NC} ${BLUE}â”‚${NC}\n" "Checks Passed" "$passed_checks / $total_checks"
    if [ $critical_issues -gt 0 ]; then
        printf "${BLUE}â”‚${NC} ${BOLD}%-20s${NC} ${BLUE}â”‚${NC} ${RED}%-34s${NC} ${BLUE}â”‚${NC}\n" "Critical Issues" "$critical_issues"
    fi
    echo -e "${BLUE}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}\n"
    
    if [ $score -lt 80 ]; then
        echo -e "${YELLOW}${BOLD}âš  RECOMMENDATIONS:${NC}\n"
        [ $critical_issues -gt 0 ] && echo -e "  ${RED}â€¢${NC} Consider getting a new IP address"
        echo -e "  ${CYAN}â€¢${NC} Detailed analysis available at:"
        echo -e "    ${BLUE}https://scamalytics.com/ip/$PUBLIC_IP${NC}"
        echo -e "    ${BLUE}https://www.abuseipdb.com/check/$PUBLIC_IP${NC}"
    fi
    
    press_enter
}

#==============================================================================
# Service Management Functions
#==============================================================================

check_service_status() {
    local service=$1
    local display_name=$2
    
    if systemctl list-unit-files | grep -q "^${service}.service"; then
        if systemctl is-active --quiet "$service"; then
            echo -e "  ${GREEN}âœ“${NC} $display_name: ${GREEN}${BOLD}Running${NC}"
            return 0
        else
            echo -e "  ${RED}âœ—${NC} $display_name: ${RED}${BOLD}Stopped${NC}"
            return 1
        fi
    else
        echo -e "  ${DIM}â—‹${NC} $display_name: ${DIM}Not installed${NC}"
        return 2
    fi
}

view_service_logs() {
    local service=$1
    local display_name=$2
    local lines=${3:-50}
    
    print_header "$display_name LOGS"
    
    if systemctl list-units --full -all | grep -Fq "$service"; then
        echo -e "${CYAN}${BOLD}Service Status:${NC}\n"
        systemctl status "$service" --no-pager -l | head -15
        echo ""
        echo -e "${CYAN}${BOLD}Recent Logs:${NC}\n"
        journalctl -u "$service" -n "$lines" --no-pager | tail -50
    else
        print_status "WARN" "$display_name is not installed"
    fi
    
    press_enter
}

manage_nginx() {
    while true; do
        print_header "NGINX WEB SERVER MANAGEMENT"
        
        check_service_status "nginx" "Nginx"
        
        echo ""
        echo -e "  ${BOLD}1${NC}) ğŸ“„ View Access Logs"
        echo -e "  ${BOLD}2${NC}) ğŸš¨ View Error Logs"
        echo -e "  ${BOLD}3${NC}) ğŸ”„ Restart Nginx"
        echo -e "  ${BOLD}4${NC}) âœ… Test Configuration"
        echo -e "  ${BOLD}5${NC}) ğŸ“Š View Service Status"
        echo -e "  ${BOLD}0${NC}) â† Back"
        echo ""
        echo -ne "${YELLOW}Your choice: ${NC}"
        read choice
        
        case $choice in
            1)
                print_header "NGINX ACCESS LOGS"
                if [ -f /var/log/nginx/access.log ]; then
                    tail -50 /var/log/nginx/access.log
                else
                    print_status "WARN" "Access log not found"
                fi
                press_enter
                ;;
            2)
                print_header "NGINX ERROR LOGS"
                if [ -f /var/log/nginx/error.log ]; then
                    tail -50 /var/log/nginx/error.log
                    [ ! -s /var/log/nginx/error.log ] && echo -e "${GREEN}  âœ“ No errors in log${NC}"
                else
                    print_status "WARN" "Error log not found"
                fi
                press_enter
                ;;
            3)
                echo ""
                nginx -t &>/dev/null
                if [ $? -eq 0 ]; then
                    systemctl restart nginx
                    print_status "SUCCESS" "Nginx restarted successfully"
                else
                    print_status "ERROR" "Configuration test failed"
                    nginx -t
                fi
                press_enter
                ;;
            4)
                print_header "NGINX CONFIGURATION TEST"
                nginx -t
                press_enter
                ;;
            5)
                view_service_logs "nginx" "Nginx"
                ;;
            0)
                return
                ;;
            *)
                print_status "ERROR" "Invalid choice"
                sleep 1
                ;;
        esac
    done
}

service_log_menu() {
    while true; do
        print_banner
        show_system_info
        print_header "SERVICE & LOG MANAGEMENT"
        
        echo -e "${CYAN}${BOLD}Service Status Overview:${NC}\n"
        
        # Check services
        check_service_status "nginx" "Nginx"
        check_service_status "apache2" "Apache" || check_service_status "httpd" "Apache"
        
        # PHP-FPM
        local php_found=0
        for ver in 8.4 8.3 8.2 8.1 8.0 7.4; do
            if systemctl list-units --full -all | grep -Fq "php${ver}-fpm"; then
                check_service_status "php${ver}-fpm" "PHP ${ver}-FPM"
                php_found=1
                break
            fi
        done
        [ $php_found -eq 0 ] && echo -e "  ${DIM}â—‹${NC} PHP-FPM: ${DIM}Not installed${NC}"
        
        check_service_status "mysql" "MySQL" || check_service_status "mariadb" "MariaDB"
        check_service_status "redis-server" "Redis" || check_service_status "redis" "Redis"
        check_service_status "docker" "Docker"
        
        echo ""
        echo -e "  ${BOLD}1${NC}) ğŸŒ Nginx Management"
        echo -e "  ${BOLD}2${NC}) ğŸ“Š System Logs (journalctl)"
        echo -e "  ${BOLD}3${NC}) ğŸ—‘ï¸  Clear All Service Logs"
        echo -e "  ${BOLD}0${NC}) â† Back"
        echo ""
        echo -ne "${YELLOW}Your choice: ${NC}"
        read choice
        
        case $choice in
            1) manage_nginx ;;
            2)
                print_header "SYSTEM LOGS"
                echo -e "  ${BOLD}1${NC}) Last 100 system logs"
                echo -e "  ${BOLD}2${NC}) System errors only"
                echo -e "  ${BOLD}0${NC}) Back"
                echo ""
                echo -ne "${YELLOW}Your choice: ${NC}"
                read log_choice
                
                case $log_choice in
                    1)
                        print_header "LAST 100 SYSTEM LOGS"
                        journalctl -n 100 --no-pager
                        press_enter
                        ;;
                    2)
                        print_header "SYSTEM ERRORS"
                        journalctl -p err -n 50 --no-pager
                        press_enter
                        ;;
                esac
                ;;
            3)
                print_header "CLEAR ALL SERVICE LOGS"
                echo -e "${YELLOW}âš  This will clear ALL service logs and journal entries${NC}\n"
                echo -ne "${RED}${BOLD}Are you sure?${NC} [y/N]: "
                read confirm
                
                if [[ $confirm =~ ^[Yy]$ ]]; then
                    echo ""
                    journalctl --rotate 2>/dev/null
                    journalctl --vacuum-time=1s >/dev/null 2>&1
                    
                    for log_file in /var/log/nginx/*.log /var/log/apache2/*.log; do
                        [ -f "$log_file" ] && > "$log_file" 2>/dev/null
                    done
                    
                    sync
                    print_status "SUCCESS" "All logs cleared"
                    press_enter
                fi
                ;;
            0) break ;;
            *) print_status "ERROR" "Invalid option"; sleep 1 ;;
        esac
    done
}

#==============================================================================
# Repository Mirror Optimizer
#==============================================================================

optimize_mirrors() {
    print_header "APT REPOSITORY MIRROR OPTIMIZER"
    
    if [ "$OS" != "ubuntu" ] && [ "$OS" != "debian" ]; then
        print_status "ERROR" "This feature only works on Ubuntu/Debian"
        press_enter
        return
    fi
    
    print_section "FINDING FASTEST MIRRORS"
    
    backup_file "/etc/apt/sources.list"
    [ -f "/etc/apt/sources.list.d/ubuntu.sources" ] && backup_file "/etc/apt/sources.list.d/ubuntu.sources"
    
    # Iranian Mirrors
    declare -A IRAN_MIRRORS=(
        ["mirror.iranserver.com"]="mirror.iranserver.com/ubuntu"
        ["ir.ubuntu.sindad.cloud"]="ir.ubuntu.sindad.cloud/ubuntu"
        ["mirror.arvancloud.ir"]="mirror.arvancloud.ir/ubuntu"
    )
    
    # International Mirrors
    declare -A INTL_MIRRORS=(
        ["archive.ubuntu.com"]="archive.ubuntu.com/ubuntu"
        ["mirrors.edge.kernel.org"]="mirrors.edge.kernel.org/ubuntu"
        ["mirror.math.princeton.edu"]="mirror.math.princeton.edu/pub/ubuntu"
    )
    
    declare -A iran_times
    declare -A intl_times
    
    # Test Iranian
    echo -e "${CYAN}${BOLD}Testing Iranian Mirrors:${NC}\n"
    
    local count=0
    local total=${#IRAN_MIRRORS[@]}
    
    for mirror in "${!IRAN_MIRRORS[@]}"; do
        count=$((count + 1))
        show_progress $count $total "Testing $mirror"
        
        ping_time=$(ping -c 2 -W 2 $mirror 2>/dev/null | grep rtt | awk -F'/' '{print $5}' | cut -d. -f1)
        
        if [ -n "$ping_time" ] && [ "$ping_time" -gt 0 ]; then
            iran_times["$mirror"]="$ping_time"
        fi
    done
    
    echo ""
    echo ""
    
    # Test International
    echo -e "${CYAN}${BOLD}Testing International Mirrors:${NC}\n"
    
    count=0
    total=${#INTL_MIRRORS[@]}
    
    for mirror in "${!INTL_MIRRORS[@]}"; do
        count=$((count + 1))
        show_progress $count $total "Testing $mirror"
        
        ping_time=$(ping -c 2 -W 2 $mirror 2>/dev/null | grep rtt | awk -F'/' '{print $5}' | cut -d. -f1)
        
        if [ -n "$ping_time" ] && [ "$ping_time" -gt 0 ]; then
            intl_times["$mirror"]="$ping_time"
        fi
    done
    
    echo ""
    echo ""
    
    # Find fastest
    BEST_IRAN=""
    BEST_IRAN_TIME=999999
    
    for mirror in "${!iran_times[@]}"; do
        time="${iran_times[$mirror]}"
        if [ "$time" -lt "$BEST_IRAN_TIME" ]; then
            BEST_IRAN_TIME=$time
            BEST_IRAN=$mirror
        fi
    done
    
    BEST_INTL=""
    BEST_INTL_TIME=999999
    
    for mirror in "${!intl_times[@]}"; do
        time="${intl_times[$mirror]}"
        if [ "$time" -lt "$BEST_INTL_TIME" ]; then
            BEST_INTL_TIME=$time
            BEST_INTL=$mirror
        fi
    done
    
    # Display results
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${GREEN}${BOLD}  âœ“ MIRROR TEST COMPLETED${NC}"
    echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"
    
    if [ -n "$BEST_IRAN" ]; then
        echo -e "${GREEN}  ğŸ‡®ğŸ‡· ${BOLD}Fastest Iranian Mirror:${NC}"
        echo -e "     ${CYAN}$BEST_IRAN${NC} - ${GREEN}${BEST_IRAN_TIME}ms${NC}\n"
    fi
    
    if [ -n "$BEST_INTL" ]; then
        echo -e "${GREEN}  ğŸŒ ${BOLD}Fastest International Mirror:${NC}"
        echo -e "     ${CYAN}$BEST_INTL${NC} - ${GREEN}${BEST_INTL_TIME}ms${NC}\n"
    fi
    
    if [ -z "$BEST_IRAN" ] && [ -z "$BEST_INTL" ]; then
        print_status "ERROR" "No mirrors responded"
        press_enter
        return
    fi
    
    echo -e "${YELLOW}${BOLD}Select mirror to use:${NC}\n"
    
    if [ -n "$BEST_IRAN" ]; then
        echo -e "  ${BOLD}1${NC}) ğŸ‡®ğŸ‡· Iranian: ${CYAN}$BEST_IRAN${NC} ${GREEN}(${BEST_IRAN_TIME}ms) [RECOMMENDED]${NC}"
    fi
    
    if [ -n "$BEST_INTL" ]; then
        echo -e "  ${BOLD}2${NC}) ğŸŒ International: ${CYAN}$BEST_INTL${NC} ${GREEN}(${BEST_INTL_TIME}ms)${NC}"
    fi
    
    echo -e "  ${BOLD}0${NC}) Cancel"
    echo ""
    echo -ne "${YELLOW}Your choice: ${NC}"
    read mirror_choice
    
    SELECTED_MIRROR=""
    SELECTED_PATH=""
    
    case $mirror_choice in
        1)
            if [ -n "$BEST_IRAN" ]; then
                SELECTED_MIRROR=$BEST_IRAN
                SELECTED_PATH="${IRAN_MIRRORS[$BEST_IRAN]}"
            fi
            ;;
        2)
            if [ -n "$BEST_INTL" ]; then
                SELECTED_MIRROR=$BEST_INTL
                SELECTED_PATH="${INTL_MIRRORS[$BEST_INTL]}"
            fi
            ;;
        0)
            return
            ;;
        *)
            print_status "ERROR" "Invalid choice"
            press_enter
            return
            ;;
    esac
    
    if [ -z "$SELECTED_MIRROR" ]; then
        print_status "ERROR" "Invalid selection"
        press_enter
        return
    fi
    
    echo ""
    print_section "APPLYING MIRROR CONFIGURATION"
    
    # Update sources
    if [ -f /etc/apt/sources.list.d/ubuntu.sources ]; then
        sed -i "s|^URIs:.*|URIs: http://$SELECTED_PATH|" /etc/apt/sources.list.d/ubuntu.sources
        print_status "SUCCESS" "Updated ubuntu.sources"
    fi
    
    if [ -f /etc/apt/sources.list ] && [ -s /etc/apt/sources.list ]; then
        sed -i "s|http://[a-zA-Z0-9./-]*archive\.ubuntu\.com/ubuntu|http://$SELECTED_PATH|g" /etc/apt/sources.list
        print_status "SUCCESS" "Updated sources.list"
    fi
    
    # Update
    rm -rf /var/lib/apt/lists/* 2>/dev/null
    echo ""
    print_status "INFO" "Updating package lists..."
    
    if apt-get update 2>&1 | grep -q "^Hit\|^Get"; then
        echo ""
        print_status "SUCCESS" "Mirror updated successfully!"
        echo -e "\n  ${GREEN}âœ“${NC} Now using: ${CYAN}http://$SELECTED_PATH${NC}"
    else
        print_status "ERROR" "Failed to update"
    fi
    
    press_enter
}

#==============================================================================
# System Benchmark
#==============================================================================

run_benchmark() {
    print_header "COMPREHENSIVE SYSTEM BENCHMARK"
    
    echo -e "${YELLOW}âš  Running performance benchmark...${NC}"
    echo -e "${DIM}  This may take several minutes${NC}\n"
    
    curl -Lso- bench.sh 2>/dev/null | bash
    
    press_enter
}

#==============================================================================
# Network Optimization Menu
#==============================================================================

network_optimization_menu() {
    while true; do
        print_banner
        show_system_info
        print_header "NETWORK & SERVER OPTIMIZATION"
        
        echo -e "  ${BOLD}1${NC}) âš¡ Install BBR (TCP Congestion Control)"
        echo -e "  ${BOLD}2${NC}) ğŸ›°ï¸  Install Hybla (High Latency Optimization)"
        echo -e "  ${BOLD}3${NC}) ğŸ—‘ï¸  Remove TCP Optimization"
        echo -e "  ${BOLD}4${NC}) ğŸ“ MTU Path Discovery & Auto-Set"
        echo -e "  ${BOLD}5${NC}) ğŸŒ DNS Optimizer (Find & Set Fastest)"
        echo -e "  ${BOLD}6${NC}) ğŸ›¡ï¸  Block/Unblock Server Ping"
        echo -e "  ${BOLD}7${NC}) ${GREEN}${BOLD}ğŸš€ Complete Server Optimization${NC}"
        echo -e "  ${BOLD}0${NC}) â† Back"
        echo ""
        echo -ne "${YELLOW}Your choice: ${NC}"
        read choice
        
        case $choice in
            1) install_bbr ;;
            2) install_hybla ;;
            3) remove_tcp_optimization ;;
            4) mtu_finder ;;
            5) optimize_dns ;;
            6) manage_ping ;;
            7) optimize_server ;;
            0) break ;;
            *) print_status "ERROR" "Invalid option"; sleep 1 ;;
        esac
    done
}

#==============================================================================
# Main Menu
#==============================================================================

main_menu() {
    while true; do
        print_banner
        show_system_info
        
        echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${CYAN}${BOLD}  MAIN MENU${NC}"
        echo -e "${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"
        
        echo -e "  ${BOLD}1${NC}) ğŸŒ Network & Server Optimization"
        echo -e "  ${BOLD}2${NC}) ğŸ” IP Reputation & Security Check"
        echo -e "  ${BOLD}3${NC}) ğŸ”„ Optimize Repository Mirrors"
        echo -e "  ${BOLD}4${NC}) ğŸ“Š Live Server Monitoring ${GREEN}${BOLD}[BTOP]${NC}"
        echo -e "  ${BOLD}5${NC}) âš¡ System Benchmark"
        echo -e "  ${BOLD}6${NC}) ğŸ”§ Service & Log Management"
        echo -e "  ${BOLD}0${NC}) âŒ Exit"
        
        echo -e "\n${CYAN}${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"
        
        echo -ne "${YELLOW}${BOLD}Select option:${NC} "
        read choice
        
        case $choice in
            1) network_optimization_menu ;;
            2) check_ip_reputation ;;
            3) optimize_mirrors ;;
            4) monitoring ;;
            5) run_benchmark ;;
            6) service_log_menu ;;
            0)
                echo ""
                echo -e "${GREEN}${BOLD}Thank you for using Server Management Tool!${NC}"
                echo -e "${DIM}Stay optimized! ğŸš€${NC}\n"
                exit 0
                ;;
            *)
                print_status "ERROR" "Invalid option"
                sleep 1
                ;;
        esac
    done
}

#==============================================================================
# Main Execution
#==============================================================================

check_root
detect_os
main_menu
