#!/usr/bin/env bash

#==============================================================================
# Server Management & Optimization Tool
# Version: 2.0.0
# Focus: Network Optimization, Performance, and Server Management
#==============================================================================

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
BOLD='\033[1m'
NC='\033[0m'

# Configuration
SCRIPT_VERSION="2.0.0"
SYSCTL_CONF="/etc/sysctl.conf"
BACKUP_DIR="/root/server-tool-backups"

# Create backup directory
mkdir -p "$BACKUP_DIR"

#==============================================================================
# Utility Functions
#==============================================================================

print_banner() {
    clear
    echo -e "${CYAN}${BOLD}"
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                               â•‘
â•‘         SERVER MANAGEMENT & OPTIMIZATION TOOL                 â•‘
â•‘                     Version 2.0.0                             â•‘
â•‘                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    echo -e "${NC}"
}

print_header() {
    echo -e "\n${BLUE}${BOLD}â•”$(printf 'â•%.0s' {1..63})â•—${NC}"
    printf "${BLUE}${BOLD}â•‘${NC} %-61s ${BLUE}${BOLD}â•‘${NC}\n" "$1"
    echo -e "${BLUE}${BOLD}â•š$(printf 'â•%.0s' {1..63})â•${NC}\n"
}

print_status() {
    local status="$1"
    local message="$2"
    case $status in
        "OK") echo -e "${GREEN}âœ“${NC} $message" ;;
        "WARN") echo -e "${YELLOW}âš ${NC} $message" ;;
        "FAIL") echo -e "${RED}âœ—${NC} $message" ;;
        "INFO") echo -e "${CYAN}â„¹${NC} $message" ;;
    esac
}

check_root() {
    if [ "$(id -u)" != "0" ]; then
        echo -e "${RED}This script must be run as root or with sudo${NC}"
        exit 1
    fi
}

detect_os() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS=$ID
        OS_VERSION=$VERSION_ID
    else
        OS=$(uname -s)
        OS_VERSION=$(uname -r)
    fi
}

backup_file() {
    local file="$1"
    if [ -f "$file" ]; then
        cp "$file" "$BACKUP_DIR/$(basename $file).backup.$(date +%Y%m%d-%H%M%S)"
        print_status "INFO" "Backup created: $file"
    fi
}

press_enter() {
    echo ""
    read -p "$(echo -e ${CYAN}Press Enter to continue...${NC})"
}

#==============================================================================
# System Information
#==============================================================================

show_system_info() {
    print_header "SYSTEM INFORMATION"
    
    # Get info
    HOSTNAME=$(hostname)
    KERNEL=$(uname -r)
    CPU_MODEL=$(lscpu | grep "Model name" | cut -d':' -f2 | xargs)
    CPU_CORES=$(nproc)
    TOTAL_MEM=$(free -h | awk '/^Mem:/ {print $2}')
    USED_MEM=$(free -h | awk '/^Mem:/ {print $3}')
    TOTAL_DISK=$(df -h / | awk 'NR==2 {print $2}')
    USED_DISK=$(df -h / | awk 'NR==2 {print $3}')
    UPTIME=$(uptime -p 2>/dev/null || uptime)
    PUBLIC_IP=$(curl -s --max-time 3 https://api.ipify.org 2>/dev/null || echo "N/A")
    
    # Display
    echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Hostname" "$HOSTNAME"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Kernel" "$KERNEL"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "CPU" "${CPU_MODEL:0:34}"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "CPU Cores" "$CPU_CORES"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Memory" "$USED_MEM / $TOTAL_MEM"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Disk" "$USED_DISK / $TOTAL_DISK"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: %-34s ${CYAN}â•‘${NC}\n" "Uptime" "${UPTIME:0:34}"
    printf "${CYAN}â•‘${NC} ${BOLD}%-20s${NC}: ${YELLOW}%-34s${NC} ${CYAN}â•‘${NC}\n" "Public IP" "$PUBLIC_IP"
    echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
}

#==============================================================================
# TCP Congestion Control - BBR
#==============================================================================

install_bbr() {
    print_header "INSTALL BBR (TCP Congestion Control)"
    
    echo -e "${YELLOW}BBR improves network throughput and reduces latency${NC}\n"
    
    # Check current
    current_cc=$(sysctl net.ipv4.tcp_congestion_control 2>/dev/null | awk '{print $3}')
    echo -e "Current congestion control: ${CYAN}$current_cc${NC}\n"
    
    if [ "$current_cc" = "bbr" ]; then
        print_status "OK" "BBR is already installed and active"
        press_enter
        return
    fi
    
    # Check kernel version
    kernel_version=$(uname -r | cut -d. -f1-2)
    major=$(echo $kernel_version | cut -d. -f1)
    minor=$(echo $kernel_version | cut -d. -f2)
    
    if [ "$major" -lt 4 ] || ([ "$major" -eq 4 ] && [ "$minor" -lt 9 ]); then
        print_status "FAIL" "BBR requires kernel 4.9+. Current: $(uname -r)"
        echo -e "${YELLOW}Please upgrade your kernel first${NC}"
        press_enter
        return
    fi
    
    print_status "OK" "Kernel version compatible: $(uname -r)"
    
    # Backup sysctl.conf
    backup_file "$SYSCTL_CONF"
    
    # Remove old BBR settings
    sed -i '/net.core.default_qdisc/d' "$SYSCTL_CONF"
    sed -i '/net.ipv4.tcp_congestion_control/d' "$SYSCTL_CONF"
    
    # Add BBR settings
    echo "" >> "$SYSCTL_CONF"
    echo "# BBR Congestion Control" >> "$SYSCTL_CONF"
    echo "net.core.default_qdisc=fq" >> "$SYSCTL_CONF"
    echo "net.ipv4.tcp_congestion_control=bbr" >> "$SYSCTL_CONF"
    
    # Apply settings
    sysctl -p > /dev/null 2>&1
    
    # Verify
    if sysctl net.ipv4.tcp_congestion_control | grep -q "bbr"; then
        print_status "OK" "BBR installed and activated successfully!"
        echo ""
        print_status "INFO" "BBR will persist after reboot"
    else
        print_status "FAIL" "Failed to activate BBR"
    fi
    
    press_enter
}

#==============================================================================
# TCP Congestion Control - Hybla
#==============================================================================

install_hybla() {
    print_header "INSTALL HYBLA (TCP Congestion Control)"
    
    echo -e "${YELLOW}Hybla is optimized for high-latency networks (satellite, long-distance)${NC}\n"
    
    # Check current
    current_cc=$(sysctl net.ipv4.tcp_congestion_control 2>/dev/null | awk '{print $3}')
    echo -e "Current congestion control: ${CYAN}$current_cc${NC}\n"
    
    if [ "$current_cc" = "hybla" ]; then
        print_status "OK" "Hybla is already installed and active"
        press_enter
        return
    fi
    
    # Load hybla module
    modprobe tcp_hybla 2>/dev/null
    
    if ! lsmod | grep -q tcp_hybla; then
        print_status "FAIL" "Cannot load tcp_hybla module"
        echo -e "${YELLOW}Your kernel may not support Hybla${NC}"
        press_enter
        return
    fi
    
    print_status "OK" "Hybla module loaded"
    
    # Make module load on boot
    if ! grep -q "tcp_hybla" /etc/modules 2>/dev/null; then
        echo "tcp_hybla" >> /etc/modules
    fi
    
    # Backup sysctl.conf
    backup_file "$SYSCTL_CONF"
    
    # Remove old settings
    sed -i '/net.core.default_qdisc/d' "$SYSCTL_CONF"
    sed -i '/net.ipv4.tcp_congestion_control/d' "$SYSCTL_CONF"
    
    # Add Hybla settings
    echo "" >> "$SYSCTL_CONF"
    echo "# Hybla Congestion Control" >> "$SYSCTL_CONF"
    echo "net.core.default_qdisc=fq" >> "$SYSCTL_CONF"
    echo "net.ipv4.tcp_congestion_control=hybla" >> "$SYSCTL_CONF"
    
    # Apply settings
    sysctl -p > /dev/null 2>&1
    
    # Verify
    if sysctl net.ipv4.tcp_congestion_control | grep -q "hybla"; then
        print_status "OK" "Hybla installed and activated successfully!"
        echo ""
        print_status "INFO" "Hybla will persist after reboot"
    else
        print_status "FAIL" "Failed to activate Hybla"
    fi
    
    press_enter
}

#==============================================================================
# Remove TCP Optimization
#==============================================================================

remove_tcp_optimization() {
    print_header "REMOVE TCP OPTIMIZATION"
    
    echo -e "${YELLOW}This will remove BBR/Hybla and restore default settings${NC}\n"
    
    read -p "$(echo -e ${RED}Are you sure? [y/N]:${NC} )" confirm
    if [[ ! $confirm =~ ^[Yy]$ ]]; then
        return
    fi
    
    # Backup sysctl.conf
    backup_file "$SYSCTL_CONF"
    
    # Remove settings
    sed -i '/# BBR Congestion Control/d' "$SYSCTL_CONF"
    sed -i '/# Hybla Congestion Control/d' "$SYSCTL_CONF"
    sed -i '/net.core.default_qdisc/d' "$SYSCTL_CONF"
    sed -i '/net.ipv4.tcp_congestion_control/d' "$SYSCTL_CONF"
    
    # Set to default (cubic)
    sysctl -w net.ipv4.tcp_congestion_control=cubic > /dev/null 2>&1
    
    # Remove hybla from modules
    sed -i '/tcp_hybla/d' /etc/modules 2>/dev/null
    
    print_status "OK" "TCP optimization removed"
    print_status "INFO" "Default congestion control (cubic) restored"
    
    press_enter
}

#==============================================================================
# MTU Finder & Optimizer
#==============================================================================

mtu_finder() {
    print_header "MTU FINDER & OPTIMIZER"
    
    # Get primary interface
    PRIMARY_IFACE=$(ip route | grep default | awk '{print $5}' | head -1)
    
    if [ -z "$PRIMARY_IFACE" ]; then
        print_status "FAIL" "Cannot detect primary network interface"
        press_enter
        return
    fi
    
    current_mtu=$(ip link show "$PRIMARY_IFACE" 2>/dev/null | grep -oP 'mtu \K\d+' || echo "1500")
    echo -e "Interface: ${CYAN}$PRIMARY_IFACE${NC}"
    echo -e "Current MTU: ${CYAN}$current_mtu${NC}\n"
    
    echo -e "${CYAN}Select test destination:${NC}"
    echo "  1) Google DNS (8.8.8.8)"
    echo "  2) Cloudflare DNS (1.1.1.1)"
    echo "  3) Custom IP"
    echo "  0) Back"
    echo ""
    read -p "Choice: " dest_choice
    
    case $dest_choice in
        1) test_ip="8.8.8.8" ;;
        2) test_ip="1.1.1.1" ;;
        3) read -p "Enter IP address: " test_ip ;;
        0) return ;;
        *) print_status "FAIL" "Invalid choice"; press_enter; return ;;
    esac
    
    # Test connectivity
    if ! ping -c 1 -W 2 "$test_ip" &>/dev/null; then
        print_status "FAIL" "Cannot reach $test_ip"
        press_enter
        return
    fi
    
    print_status "OK" "Testing connectivity to $test_ip"
    
    echo ""
    echo -e "${CYAN}Finding optimal MTU...${NC}\n"
    
    # Binary search for optimal MTU
    local min_mtu=1000
    local max_mtu=1500
    local optimal_mtu=$min_mtu
    local step=10
    
    for ((mtu=$min_mtu; mtu<=$max_mtu; mtu+=$step)); do
        local payload=$((mtu - 28))
        echo -ne "${GRAY}Testing MTU $mtu...${NC}\r"
        
        if ping -M do -c 1 -s $payload -W 1 "$test_ip" &>/dev/null; then
            optimal_mtu=$mtu
            echo -e "${GREEN}âœ“${NC} MTU $mtu: ${GREEN}OK${NC}     "
        else
            echo -e "${RED}âœ—${NC} MTU $mtu: ${RED}Failed${NC}"
            break
        fi
    done
    
    # Recommend MTU
    local recommended_mtu=$((optimal_mtu - 2))
    
    echo ""
    print_status "OK" "Optimal MTU found: $optimal_mtu"
    print_status "INFO" "Recommended MTU: $recommended_mtu"
    
    echo ""
    read -p "$(echo -e ${YELLOW}Apply MTU $recommended_mtu? [y/N]:${NC} )" apply_mtu
    
    if [[ $apply_mtu =~ ^[Yy]$ ]]; then
        # Set MTU temporarily
        ip link set dev "$PRIMARY_IFACE" mtu "$recommended_mtu" 2>/dev/null
        print_status "OK" "MTU temporarily set to $recommended_mtu"
        
        # Make permanent
        if [ -f "/etc/network/interfaces" ]; then
            backup_file "/etc/network/interfaces"
            if ! grep -q "mtu $recommended_mtu" /etc/network/interfaces; then
                sed -i "/iface $PRIMARY_IFACE/a \    mtu $recommended_mtu" /etc/network/interfaces 2>/dev/null
                print_status "OK" "MTU saved to /etc/network/interfaces"
            fi
        elif [ -f "/etc/sysconfig/network-scripts/ifcfg-$PRIMARY_IFACE" ]; then
            local ifcfg="/etc/sysconfig/network-scripts/ifcfg-$PRIMARY_IFACE"
            backup_file "$ifcfg"
            if grep -q "MTU=" "$ifcfg"; then
                sed -i "s/MTU=.*/MTU=$recommended_mtu/" "$ifcfg"
            else
                echo "MTU=$recommended_mtu" >> "$ifcfg"
            fi
            print_status "OK" "MTU saved to $ifcfg"
        else
            print_status "WARN" "Manual configuration may be needed for persistence"
        fi
        
        print_status "INFO" "MTU will persist after reboot"
    fi
    
    press_enter
}

#==============================================================================
# DNS Optimizer
#==============================================================================

optimize_dns() {
    print_header "DNS OPTIMIZER"
    
    echo -e "${YELLOW}Testing multiple DNS servers to find the fastest...${NC}\n"
    
    # DNS servers to test
    declare -A dns_servers=(
        ["Google"]="8.8.8.8"
        ["Cloudflare"]="1.1.1.1"
        ["Quad9"]="9.9.9.9"
        ["OpenDNS"]="208.67.222.222"
        ["Shecan"]="178.22.122.100"
        ["403"]="10.202.10.202"
    )
    
    declare -A dns_times
    
    # Test each DNS
    for name in "${!dns_servers[@]}"; do
        ip="${dns_servers[$name]}"
        echo -ne "${GRAY}Testing $name ($ip)...${NC}\r"
        
        # Test with dig
        if command -v dig &>/dev/null; then
            response_time=$(dig @$ip google.com +stats 2>/dev/null | grep "Query time:" | awk '{print $4}')
            if [ -n "$response_time" ]; then
                dns_times["$name"]="$response_time"
                echo -e "${GREEN}âœ“${NC} $name ($ip): ${CYAN}${response_time}ms${NC}          "
            else
                echo -e "${RED}âœ—${NC} $name ($ip): ${RED}Failed${NC}          "
            fi
        else
            # Fallback to ping
            ping_time=$(ping -c 3 -W 2 $ip 2>/dev/null | tail -1 | awk -F'/' '{print $5}' | cut -d'.' -f1)
            if [ -n "$ping_time" ]; then
                dns_times["$name"]="$ping_time"
                echo -e "${GREEN}âœ“${NC} $name ($ip): ${CYAN}~${ping_time}ms${NC}          "
            else
                echo -e "${RED}âœ—${NC} $name ($ip): ${RED}Failed${NC}          "
            fi
        fi
    done
    
    # Find fastest
    fastest_dns=""
    fastest_time=999999
    
    for name in "${!dns_times[@]}"; do
        time="${dns_times[$name]}"
        if [ "$time" -lt "$fastest_time" ]; then
            fastest_time=$time
            fastest_dns=$name
        fi
    done
    
    if [ -z "$fastest_dns" ]; then
        print_status "FAIL" "No DNS servers responded"
        press_enter
        return
    fi
    
    fastest_ip="${dns_servers[$fastest_dns]}"
    
    echo ""
    print_status "OK" "Fastest DNS: $fastest_dns ($fastest_ip) - ${fastest_time}ms"
    
    echo ""
    read -p "$(echo -e ${YELLOW}Apply this DNS? [y/N]:${NC} )" apply_dns
    
    if [[ $apply_dns =~ ^[Yy]$ ]]; then
        # Backup resolv.conf
        backup_file "/etc/resolv.conf"
        
        # Set DNS
        cat > /etc/resolv.conf << EOF
nameserver $fastest_ip
nameserver 8.8.8.8
EOF
        
        # Make immutable (prevent changes)
        chattr +i /etc/resolv.conf 2>/dev/null || true
        
        print_status "OK" "DNS set to $fastest_dns ($fastest_ip)"
        print_status "INFO" "DNS will persist after reboot"
    fi
    
    press_enter
}

#==============================================================================
# Block/Unblock ICMP (Ping)
#==============================================================================

manage_ping() {
    print_header "BLOCK/UNBLOCK SERVER PING"
    
    # Check current status
    current_setting=$(sysctl net.ipv4.icmp_echo_ignore_all 2>/dev/null | awk '{print $3}')
    
    if [ "$current_setting" = "1" ]; then
        echo -e "Current status: ${RED}Ping is BLOCKED${NC}\n"
    else
        echo -e "Current status: ${GREEN}Ping is ALLOWED${NC}\n"
    fi
    
    echo "  1) Block Ping"
    echo "  2) Unblock Ping"
    echo "  0) Back"
    echo ""
    read -p "Choice: " ping_choice
    
    case $ping_choice in
        1)
            # Block ping
            backup_file "$SYSCTL_CONF"
            sed -i '/net.ipv4.icmp_echo_ignore_all/d' "$SYSCTL_CONF"
            echo "net.ipv4.icmp_echo_ignore_all=1" >> "$SYSCTL_CONF"
            sysctl -w net.ipv4.icmp_echo_ignore_all=1 > /dev/null 2>&1
            print_status "OK" "Ping blocked successfully"
            print_status "INFO" "Setting will persist after reboot"
            ;;
        2)
            # Unblock ping
            backup_file "$SYSCTL_CONF"
            sed -i '/net.ipv4.icmp_echo_ignore_all/d' "$SYSCTL_CONF"
            echo "net.ipv4.icmp_echo_ignore_all=0" >> "$SYSCTL_CONF"
            sysctl -w net.ipv4.icmp_echo_ignore_all=0 > /dev/null 2>&1
            print_status "OK" "Ping unblocked successfully"
            print_status "INFO" "Setting will persist after reboot"
            ;;
        0)
            return
            ;;
        *)
            print_status "FAIL" "Invalid choice"
            ;;
    esac
    
    press_enter
}

#==============================================================================
# Complete Server Optimization
#==============================================================================

optimize_server() {
    print_header "COMPLETE SERVER OPTIMIZATION"
    
    echo -e "${YELLOW}This will apply comprehensive system optimizations${NC}"
    echo -e "${YELLOW}Including: Memory, Network, File System, and Security${NC}\n"
    
    echo -e "${RED}âš  WARNING: This will modify system configuration files${NC}\n"
    
    read -p "$(echo -e ${YELLOW}Continue? [y/N]:${NC} )" confirm
    if [[ ! $confirm =~ ^[Yy]$ ]]; then
        return
    fi
    
    echo ""
    print_status "INFO" "Backing up configuration files..."
    
    # Backup files
    backup_file "$SYSCTL_CONF"
    backup_file "/etc/security/limits.conf"
    
    # Create new sysctl.conf
    cat > "$SYSCTL_CONF" << 'EOF'
# Server Optimization Configuration
# Generated by Server Management Tool

# Memory Management
vm.swappiness=10
vm.dirty_ratio=20
vm.dirty_background_ratio=10

# File System
fs.file-max=2097152

# Network Core
net.core.somaxconn=4096
net.core.netdev_max_backlog=16384

# IPv4 Network
net.ipv4.ip_local_port_range=1024 65535
net.ipv4.ip_nonlocal_bind=1

# TCP Configuration
net.ipv4.tcp_fin_timeout=15
net.ipv4.tcp_keepalive_time=300
net.ipv4.tcp_syncookies=0
net.ipv4.tcp_max_orphans=262144
net.ipv4.tcp_max_syn_backlog=8192
net.ipv4.tcp_max_tw_buckets=262144
net.ipv4.tcp_reordering=3

# TCP Memory
net.ipv4.tcp_mem=786432 1697152 1945728
net.ipv4.tcp_rmem=4096 87380 16777216
net.ipv4.tcp_wmem=4096 65536 16777216

# TCP Retries
net.ipv4.tcp_syn_retries=5

# TCP Reuse
net.ipv4.tcp_tw_reuse=1
EOF
    
    print_status "OK" "Created new sysctl.conf"
    
    # Create new limits.conf
    cat > /etc/security/limits.conf << 'EOF'
# System Limits Configuration
# Generated by Server Management Tool

* soft nproc 65535
* hard nproc 65535
* soft nofile 1048576
* hard nofile 1048576

root soft nproc 65535
root hard nproc 65535
root soft nofile 1048576
root hard nofile 1048576
EOF
    
    print_status "OK" "Created new limits.conf"
    
    # Apply sysctl settings
    print_status "INFO" "Applying kernel parameters..."
    sysctl -p > /dev/null 2>&1
    
    print_status "OK" "System optimization completed!"
    
    echo ""
    echo -e "${CYAN}Applied optimizations:${NC}"
    echo -e "  ${GREEN}âœ“${NC} Memory management (swappiness, dirty ratio)"
    echo -e "  ${GREEN}âœ“${NC} File system limits (file-max)"
    echo -e "  ${GREEN}âœ“${NC} Network buffers and backlog"
    echo -e "  ${GREEN}âœ“${NC} TCP parameters (timeouts, memory)"
    echo -e "  ${GREEN}âœ“${NC} Process and file descriptor limits"
    
    echo ""
    print_status "INFO" "All settings will persist after reboot"
    print_status "INFO" "Backups saved in: $BACKUP_DIR"
    
    press_enter
}

#==============================================================================
# IP Reputation & Security Check
#==============================================================================

check_ip_reputation() {
    print_header "IP REPUTATION & SECURITY CHECK"
    
    # Get public IP
    PUBLIC_IP=$(curl -s --max-time 5 https://api.ipify.org 2>/dev/null || echo "N/A")
    
    if [ "$PUBLIC_IP" = "N/A" ]; then
        print_status "FAIL" "Cannot get public IP address"
        press_enter
        return
    fi
    
    echo -e "${CYAN}Your Public IP: ${YELLOW}$PUBLIC_IP${NC}\n"
    
    echo -e "${YELLOW}To check your IP reputation and DNS leaks, visit these sites:${NC}\n"
    
    echo -e "${GREEN}1. BrowserLeaks IP:${NC}"
    echo -e "   ${BLUE}https://browserleaks.com/ip${NC}"
    echo -e "   Check IP, location, and basic info\n"
    
    echo -e "${GREEN}2. BrowserLeaks JavaScript:${NC}"
    echo -e "   ${BLUE}https://browserleaks.com/javascript${NC}"
    echo -e "   Advanced IP and browser fingerprinting\n"
    
    echo -e "${GREEN}3. DNS Leak Test:${NC}"
    echo -e "   ${BLUE}https://dnsleaktest.org/dns-leak-test${NC}"
    echo -e "   Check if DNS is leaking\n"
    
    echo -e "${GREEN}4. Scamalytics:${NC}"
    echo -e "   ${BLUE}https://scamalytics.com/ip/$PUBLIC_IP${NC}"
    echo -e "   Check IP fraud score\n"
    
    echo -e "${GREEN}5. Whoer:${NC}"
    echo -e "   ${BLUE}https://whoer.net/${NC}"
    echo -e "   Complete IP analysis and anonymity check\n"
    
    echo -e "${CYAN}${BOLD}Quick API Checks:${NC}\n"
    
    # Quick check with ipapi
    echo -ne "${GRAY}Checking IP information...${NC}\r"
    ip_info=$(curl -s "http://ip-api.com/json/$PUBLIC_IP" 2>/dev/null)
    
    if [ -n "$ip_info" ]; then
        country=$(echo "$ip_info" | grep -o '"country":"[^"]*' | cut -d'"' -f4)
        city=$(echo "$ip_info" | grep -o '"city":"[^"]*' | cut -d'"' -f4)
        isp=$(echo "$ip_info" | grep -o '"isp":"[^"]*' | cut -d'"' -f4)
        
        echo -e "${GREEN}âœ“${NC} Location: $city, $country"
        echo -e "${GREEN}âœ“${NC} ISP: $isp"
    else
        echo -e "${YELLOW}âš ${NC} Could not fetch IP info"
    fi
    
    # Check blacklist
    echo -ne "${GRAY}Checking DNS blacklists...${NC}\r"
    local blacklisted=0
    local reversed_ip=$(echo "$PUBLIC_IP" | awk -F. '{print $4"."$3"."$2"."$1}')
    
    for rbl in "zen.spamhaus.org" "bl.spamcop.net"; do
        if host "${reversed_ip}.${rbl}" &>/dev/null; then
            blacklisted=1
            break
        fi
    done
    
    if [ $blacklisted -eq 0 ]; then
        echo -e "${GREEN}âœ“${NC} IP not found in major blacklists         "
    else
        echo -e "${RED}âœ—${NC} IP found in blacklists! (May be dirty)    "
    fi
    
    echo ""
    echo -e "${YELLOW}For complete analysis, please visit the websites above${NC}"
    
    press_enter
}

network_optimization_menu() {
    while true; do
        print_banner
        show_system_info
        
        print_header "NETWORK & SERVER OPTIMIZATION"
        
        echo -e "${WHITE}  1)${NC} Install BBR (TCP Congestion Control)"
        echo -e "${WHITE}  2)${NC} Install Hybla (TCP for High Latency)"
        echo -e "${WHITE}  3)${NC} Remove TCP Optimization (BBR/Hybla)"
        echo -e "${WHITE}  4)${NC} MTU Finder + Auto Set"
        echo -e "${WHITE}  5)${NC} DNS Optimizer (Find & Set Fastest)"
        echo -e "${WHITE}  6)${NC} Block/Unblock Server Ping"
        echo -e "${WHITE}  7)${NC} ${BOLD}Complete Server Optimization${NC} ${CYAN}(Memory, TCP, Limits)${NC}"
        echo -e "${WHITE}  0)${NC} â† Back to Main Menu"
        
        echo ""
        read -p "$(echo -e ${YELLOW}Select option:${NC} )" choice
        
        case $choice in
            1) install_bbr ;;
            2) install_hybla ;;
            3) remove_tcp_optimization ;;
            4) mtu_finder ;;
            5) optimize_dns ;;
            6) manage_ping ;;
            7) optimize_server ;;
            0) break ;;
            *) print_status "FAIL" "Invalid option"; sleep 1 ;;
        esac
    done
}

#==============================================================================
# Repository Mirror Optimizer
#==============================================================================

optimize_mirrors() {
    print_header "OPTIMIZE APT MIRRORS"
    
    if [ "$OS" != "ubuntu" ] && [ "$OS" != "debian" ]; then
        print_status "FAIL" "This feature only works on Ubuntu/Debian"
        press_enter
        return
    fi
    
    echo -e "${YELLOW}Finding fastest mirror for your server...${NC}\n"
    
    # Backup sources
    backup_file "/etc/apt/sources.list"
    [ -f "/etc/apt/sources.list.d/ubuntu.sources" ] && backup_file "/etc/apt/sources.list.d/ubuntu.sources"
    
    # Iran mirrors
    MIRRORS="mirror.iranserver.com ir.ubuntu.sindad.cloud mirror.arvancloud.ir archive.ubuntu.petiak.ir ubuntu.hostiran.ir mirrors.pardisco.co ubuntu.pars.host mirror.0-1.cloud ubuntu.shatel.ir mirror.faraso.org repo.linuxmirrors.ir"
    
    echo -e "${CYAN}Testing Iran mirrors...${NC}\n"
    
    declare -A mirror_times
    
    for mirror in $MIRRORS; do
        echo -ne "${GRAY}Testing $mirror...${NC}\r"
        
        # Ping test
        ping_time=$(ping -c 2 -W 1 $mirror 2>/dev/null | grep rtt | awk -F'/' '{print $5}' | cut -d. -f1)
        
        if [ -n "$ping_time" ] && [ "$ping_time" -gt 0 ]; then
            mirror_times["$mirror"]="$ping_time"
            echo -e "${GREEN}âœ“${NC} $mirror: ${CYAN}${ping_time}ms${NC}          "
        else
            echo -e "${RED}âœ—${NC} $mirror: ${RED}Failed${NC}          "
        fi
    done
    
    # Find fastest
    BEST=""
    BEST_TIME=999999
    
    for mirror in "${!mirror_times[@]}"; do
        time="${mirror_times[$mirror]}"
        if [ "$time" -lt "$BEST_TIME" ]; then
            BEST_TIME=$time
            BEST=$mirror
        fi
    done
    
    if [ -z "$BEST" ]; then
        print_status "FAIL" "No mirror responded"
        press_enter
        return
    fi
    
    echo ""
    print_status "OK" "Fastest mirror: $BEST (${BEST_TIME}ms)"
    
    echo ""
    read -p "$(echo -e ${YELLOW}Apply this mirror? [y/N]:${NC} )" apply_mirror
    
    if [[ $apply_mirror =~ ^[Yy]$ ]]; then
        echo -e "${CYAN}Applying mirror...${NC}"
        
        # Update ubuntu.sources (Ubuntu 24.04+)
        if [ -f /etc/apt/sources.list.d/ubuntu.sources ]; then
            sed -i.bak "s|URIs: .*|URIs: http://$BEST/ubuntu/|" /etc/apt/sources.list.d/ubuntu.sources
            print_status "OK" "Updated ubuntu.sources"
        fi
        
        # Update sources.list (older Ubuntu/Debian)
        if [ -f /etc/apt/sources.list ]; then
            sed -i.bak "s|http://[a-zA-Z0-9.-]*archive.ubuntu.com/ubuntu|http://$BEST/ubuntu|g" /etc/apt/sources.list
            print_status "OK" "Updated sources.list"
        fi
        
        # Clean and update
        rm -rf /var/lib/apt/lists/* 2>/dev/null
        print_status "INFO" "Updating package lists..."
        apt-get update -qq > /dev/null 2>&1
        
        print_status "OK" "Mirror updated successfully!"
    fi
    
    press_enter
}

#==============================================================================
# System Benchmark
#==============================================================================

run_benchmark() {
    print_header "SYSTEM BENCHMARK"
    
    echo -e "${YELLOW}Running comprehensive benchmark...${NC}\n"
    echo -e "${CYAN}This may take a few minutes${NC}\n"
    
    # Run bench.sh
    curl -Lso- bench.sh 2>/dev/null | bash
    
    press_enter
}

#==============================================================================
# Main Menu
#==============================================================================

main_menu() {
    while true; do
        print_banner
        show_system_info
        
        echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
        echo -e "${CYAN}${BOLD}                      MAIN MENU                            ${NC}"
        echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
        
        echo -e "${WHITE}  1)${NC} ğŸŒ Network & Server Optimization"
        echo -e "${WHITE}  2)${NC} ğŸ” Check IP Reputation & Security"
        echo -e "${WHITE}  3)${NC} ğŸ“Š System Benchmark"
        echo -e "${WHITE}  4)${NC} ğŸ”„ Optimize Repository Mirrors"
        echo -e "${WHITE}  0)${NC} âŒ Exit"
        
        echo -e "\n${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
        
        read -p "$(echo -e ${YELLOW}Select option:${NC} )" choice
        
        case $choice in
            1) network_optimization_menu ;;
            2) check_ip_reputation ;;
            3) run_benchmark ;;
            4) optimize_mirrors ;;
            0) 
                echo -e "\n${GREEN}Thank you for using Server Management Tool!${NC}\n"
                exit 0
                ;;
            *)
                print_status "FAIL" "Invalid option"
                sleep 1
                ;;
        esac
    done
}

#==============================================================================
# Main Execution
#==============================================================================

# Check root
check_root

# Detect OS
detect_os

# Start
main_menu
